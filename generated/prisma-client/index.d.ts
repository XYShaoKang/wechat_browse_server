// Code generated by Prisma (prisma@1.32.2). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  app: (where?: AppWhereInput) => Promise<boolean>;
  avatar: (where?: AvatarWhereInput) => Promise<boolean>;
  chatRoom: (where?: ChatRoomWhereInput) => Promise<boolean>;
  contact: (where?: ContactWhereInput) => Promise<boolean>;
  content: (where?: ContentWhereInput) => Promise<boolean>;
  file: (where?: FileWhereInput) => Promise<boolean>;
  fileGroup: (where?: FileGroupWhereInput) => Promise<boolean>;
  fileIndex: (where?: FileIndexWhereInput) => Promise<boolean>;
  image: (where?: ImageWhereInput) => Promise<boolean>;
  message: (where?: MessageWhereInput) => Promise<boolean>;
  text: (where?: TextWhereInput) => Promise<boolean>;
  url: (where?: UrlWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  video: (where?: VideoWhereInput) => Promise<boolean>;
  voice: (where?: VoiceWhereInput) => Promise<boolean>;
  weChat: (where?: WeChatWhereInput) => Promise<boolean>;
  weChatUser: (where?: WeChatUserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  app: (where: AppWhereUniqueInput) => AppNullablePromise;
  apps: (args?: {
    where?: AppWhereInput;
    orderBy?: AppOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<App>;
  appsConnection: (args?: {
    where?: AppWhereInput;
    orderBy?: AppOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AppConnectionPromise;
  avatar: (where: AvatarWhereUniqueInput) => AvatarNullablePromise;
  avatars: (args?: {
    where?: AvatarWhereInput;
    orderBy?: AvatarOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Avatar>;
  avatarsConnection: (args?: {
    where?: AvatarWhereInput;
    orderBy?: AvatarOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AvatarConnectionPromise;
  chatRoom: (where: ChatRoomWhereUniqueInput) => ChatRoomNullablePromise;
  chatRooms: (args?: {
    where?: ChatRoomWhereInput;
    orderBy?: ChatRoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ChatRoom>;
  chatRoomsConnection: (args?: {
    where?: ChatRoomWhereInput;
    orderBy?: ChatRoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ChatRoomConnectionPromise;
  contact: (where: ContactWhereUniqueInput) => ContactNullablePromise;
  contacts: (args?: {
    where?: ContactWhereInput;
    orderBy?: ContactOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Contact>;
  contactsConnection: (args?: {
    where?: ContactWhereInput;
    orderBy?: ContactOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ContactConnectionPromise;
  content: (where: ContentWhereUniqueInput) => ContentNullablePromise;
  contents: (args?: {
    where?: ContentWhereInput;
    orderBy?: ContentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Content>;
  contentsConnection: (args?: {
    where?: ContentWhereInput;
    orderBy?: ContentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ContentConnectionPromise;
  file: (where: FileWhereUniqueInput) => FileNullablePromise;
  files: (args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<File>;
  filesConnection: (args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FileConnectionPromise;
  fileGroup: (where: FileGroupWhereUniqueInput) => FileGroupNullablePromise;
  fileGroups: (args?: {
    where?: FileGroupWhereInput;
    orderBy?: FileGroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<FileGroup>;
  fileGroupsConnection: (args?: {
    where?: FileGroupWhereInput;
    orderBy?: FileGroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FileGroupConnectionPromise;
  fileIndex: (where: FileIndexWhereUniqueInput) => FileIndexNullablePromise;
  fileIndexes: (args?: {
    where?: FileIndexWhereInput;
    orderBy?: FileIndexOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<FileIndex>;
  fileIndexesConnection: (args?: {
    where?: FileIndexWhereInput;
    orderBy?: FileIndexOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FileIndexConnectionPromise;
  image: (where: ImageWhereUniqueInput) => ImageNullablePromise;
  images: (args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Image>;
  imagesConnection: (args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ImageConnectionPromise;
  message: (where: MessageWhereUniqueInput) => MessageNullablePromise;
  messages: (args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Message>;
  messagesConnection: (args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MessageConnectionPromise;
  text: (where: TextWhereUniqueInput) => TextNullablePromise;
  texts: (args?: {
    where?: TextWhereInput;
    orderBy?: TextOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Text>;
  textsConnection: (args?: {
    where?: TextWhereInput;
    orderBy?: TextOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TextConnectionPromise;
  url: (where: UrlWhereUniqueInput) => UrlNullablePromise;
  urls: (args?: {
    where?: UrlWhereInput;
    orderBy?: UrlOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Url>;
  urlsConnection: (args?: {
    where?: UrlWhereInput;
    orderBy?: UrlOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UrlConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  video: (where: VideoWhereUniqueInput) => VideoNullablePromise;
  videos: (args?: {
    where?: VideoWhereInput;
    orderBy?: VideoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Video>;
  videosConnection: (args?: {
    where?: VideoWhereInput;
    orderBy?: VideoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => VideoConnectionPromise;
  voice: (where: VoiceWhereUniqueInput) => VoiceNullablePromise;
  voices: (args?: {
    where?: VoiceWhereInput;
    orderBy?: VoiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Voice>;
  voicesConnection: (args?: {
    where?: VoiceWhereInput;
    orderBy?: VoiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => VoiceConnectionPromise;
  weChat: (where: WeChatWhereUniqueInput) => WeChatNullablePromise;
  weChats: (args?: {
    where?: WeChatWhereInput;
    orderBy?: WeChatOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<WeChat>;
  weChatsConnection: (args?: {
    where?: WeChatWhereInput;
    orderBy?: WeChatOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => WeChatConnectionPromise;
  weChatUser: (where: WeChatUserWhereUniqueInput) => WeChatUserNullablePromise;
  weChatUsers: (args?: {
    where?: WeChatUserWhereInput;
    orderBy?: WeChatUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<WeChatUser>;
  weChatUsersConnection: (args?: {
    where?: WeChatUserWhereInput;
    orderBy?: WeChatUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => WeChatUserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createApp: (data: AppCreateInput) => AppPromise;
  updateApp: (args: {
    data: AppUpdateInput;
    where: AppWhereUniqueInput;
  }) => AppPromise;
  updateManyApps: (args: {
    data: AppUpdateManyMutationInput;
    where?: AppWhereInput;
  }) => BatchPayloadPromise;
  upsertApp: (args: {
    where: AppWhereUniqueInput;
    create: AppCreateInput;
    update: AppUpdateInput;
  }) => AppPromise;
  deleteApp: (where: AppWhereUniqueInput) => AppPromise;
  deleteManyApps: (where?: AppWhereInput) => BatchPayloadPromise;
  createAvatar: (data: AvatarCreateInput) => AvatarPromise;
  updateAvatar: (args: {
    data: AvatarUpdateInput;
    where: AvatarWhereUniqueInput;
  }) => AvatarPromise;
  upsertAvatar: (args: {
    where: AvatarWhereUniqueInput;
    create: AvatarCreateInput;
    update: AvatarUpdateInput;
  }) => AvatarPromise;
  deleteAvatar: (where: AvatarWhereUniqueInput) => AvatarPromise;
  deleteManyAvatars: (where?: AvatarWhereInput) => BatchPayloadPromise;
  createChatRoom: (data: ChatRoomCreateInput) => ChatRoomPromise;
  updateChatRoom: (args: {
    data: ChatRoomUpdateInput;
    where: ChatRoomWhereUniqueInput;
  }) => ChatRoomPromise;
  updateManyChatRooms: (args: {
    data: ChatRoomUpdateManyMutationInput;
    where?: ChatRoomWhereInput;
  }) => BatchPayloadPromise;
  upsertChatRoom: (args: {
    where: ChatRoomWhereUniqueInput;
    create: ChatRoomCreateInput;
    update: ChatRoomUpdateInput;
  }) => ChatRoomPromise;
  deleteChatRoom: (where: ChatRoomWhereUniqueInput) => ChatRoomPromise;
  deleteManyChatRooms: (where?: ChatRoomWhereInput) => BatchPayloadPromise;
  createContact: (data: ContactCreateInput) => ContactPromise;
  updateContact: (args: {
    data: ContactUpdateInput;
    where: ContactWhereUniqueInput;
  }) => ContactPromise;
  updateManyContacts: (args: {
    data: ContactUpdateManyMutationInput;
    where?: ContactWhereInput;
  }) => BatchPayloadPromise;
  upsertContact: (args: {
    where: ContactWhereUniqueInput;
    create: ContactCreateInput;
    update: ContactUpdateInput;
  }) => ContactPromise;
  deleteContact: (where: ContactWhereUniqueInput) => ContactPromise;
  deleteManyContacts: (where?: ContactWhereInput) => BatchPayloadPromise;
  createContent: (data: ContentCreateInput) => ContentPromise;
  updateContent: (args: {
    data: ContentUpdateInput;
    where: ContentWhereUniqueInput;
  }) => ContentPromise;
  upsertContent: (args: {
    where: ContentWhereUniqueInput;
    create: ContentCreateInput;
    update: ContentUpdateInput;
  }) => ContentPromise;
  deleteContent: (where: ContentWhereUniqueInput) => ContentPromise;
  deleteManyContents: (where?: ContentWhereInput) => BatchPayloadPromise;
  createFile: (data: FileCreateInput) => FilePromise;
  updateFile: (args: {
    data: FileUpdateInput;
    where: FileWhereUniqueInput;
  }) => FilePromise;
  updateManyFiles: (args: {
    data: FileUpdateManyMutationInput;
    where?: FileWhereInput;
  }) => BatchPayloadPromise;
  upsertFile: (args: {
    where: FileWhereUniqueInput;
    create: FileCreateInput;
    update: FileUpdateInput;
  }) => FilePromise;
  deleteFile: (where: FileWhereUniqueInput) => FilePromise;
  deleteManyFiles: (where?: FileWhereInput) => BatchPayloadPromise;
  createFileGroup: (data: FileGroupCreateInput) => FileGroupPromise;
  updateFileGroup: (args: {
    data: FileGroupUpdateInput;
    where: FileGroupWhereUniqueInput;
  }) => FileGroupPromise;
  updateManyFileGroups: (args: {
    data: FileGroupUpdateManyMutationInput;
    where?: FileGroupWhereInput;
  }) => BatchPayloadPromise;
  upsertFileGroup: (args: {
    where: FileGroupWhereUniqueInput;
    create: FileGroupCreateInput;
    update: FileGroupUpdateInput;
  }) => FileGroupPromise;
  deleteFileGroup: (where: FileGroupWhereUniqueInput) => FileGroupPromise;
  deleteManyFileGroups: (where?: FileGroupWhereInput) => BatchPayloadPromise;
  createFileIndex: (data: FileIndexCreateInput) => FileIndexPromise;
  updateFileIndex: (args: {
    data: FileIndexUpdateInput;
    where: FileIndexWhereUniqueInput;
  }) => FileIndexPromise;
  updateManyFileIndexes: (args: {
    data: FileIndexUpdateManyMutationInput;
    where?: FileIndexWhereInput;
  }) => BatchPayloadPromise;
  upsertFileIndex: (args: {
    where: FileIndexWhereUniqueInput;
    create: FileIndexCreateInput;
    update: FileIndexUpdateInput;
  }) => FileIndexPromise;
  deleteFileIndex: (where: FileIndexWhereUniqueInput) => FileIndexPromise;
  deleteManyFileIndexes: (where?: FileIndexWhereInput) => BatchPayloadPromise;
  createImage: (data: ImageCreateInput) => ImagePromise;
  updateImage: (args: {
    data: ImageUpdateInput;
    where: ImageWhereUniqueInput;
  }) => ImagePromise;
  upsertImage: (args: {
    where: ImageWhereUniqueInput;
    create: ImageCreateInput;
    update: ImageUpdateInput;
  }) => ImagePromise;
  deleteImage: (where: ImageWhereUniqueInput) => ImagePromise;
  deleteManyImages: (where?: ImageWhereInput) => BatchPayloadPromise;
  createMessage: (data: MessageCreateInput) => MessagePromise;
  updateMessage: (args: {
    data: MessageUpdateInput;
    where: MessageWhereUniqueInput;
  }) => MessagePromise;
  updateManyMessages: (args: {
    data: MessageUpdateManyMutationInput;
    where?: MessageWhereInput;
  }) => BatchPayloadPromise;
  upsertMessage: (args: {
    where: MessageWhereUniqueInput;
    create: MessageCreateInput;
    update: MessageUpdateInput;
  }) => MessagePromise;
  deleteMessage: (where: MessageWhereUniqueInput) => MessagePromise;
  deleteManyMessages: (where?: MessageWhereInput) => BatchPayloadPromise;
  createText: (data: TextCreateInput) => TextPromise;
  updateText: (args: {
    data: TextUpdateInput;
    where: TextWhereUniqueInput;
  }) => TextPromise;
  updateManyTexts: (args: {
    data: TextUpdateManyMutationInput;
    where?: TextWhereInput;
  }) => BatchPayloadPromise;
  upsertText: (args: {
    where: TextWhereUniqueInput;
    create: TextCreateInput;
    update: TextUpdateInput;
  }) => TextPromise;
  deleteText: (where: TextWhereUniqueInput) => TextPromise;
  deleteManyTexts: (where?: TextWhereInput) => BatchPayloadPromise;
  createUrl: (data: UrlCreateInput) => UrlPromise;
  updateUrl: (args: {
    data: UrlUpdateInput;
    where: UrlWhereUniqueInput;
  }) => UrlPromise;
  updateManyUrls: (args: {
    data: UrlUpdateManyMutationInput;
    where?: UrlWhereInput;
  }) => BatchPayloadPromise;
  upsertUrl: (args: {
    where: UrlWhereUniqueInput;
    create: UrlCreateInput;
    update: UrlUpdateInput;
  }) => UrlPromise;
  deleteUrl: (where: UrlWhereUniqueInput) => UrlPromise;
  deleteManyUrls: (where?: UrlWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createVideo: (data: VideoCreateInput) => VideoPromise;
  updateVideo: (args: {
    data: VideoUpdateInput;
    where: VideoWhereUniqueInput;
  }) => VideoPromise;
  updateManyVideos: (args: {
    data: VideoUpdateManyMutationInput;
    where?: VideoWhereInput;
  }) => BatchPayloadPromise;
  upsertVideo: (args: {
    where: VideoWhereUniqueInput;
    create: VideoCreateInput;
    update: VideoUpdateInput;
  }) => VideoPromise;
  deleteVideo: (where: VideoWhereUniqueInput) => VideoPromise;
  deleteManyVideos: (where?: VideoWhereInput) => BatchPayloadPromise;
  createVoice: (data: VoiceCreateInput) => VoicePromise;
  updateVoice: (args: {
    data: VoiceUpdateInput;
    where: VoiceWhereUniqueInput;
  }) => VoicePromise;
  updateManyVoices: (args: {
    data: VoiceUpdateManyMutationInput;
    where?: VoiceWhereInput;
  }) => BatchPayloadPromise;
  upsertVoice: (args: {
    where: VoiceWhereUniqueInput;
    create: VoiceCreateInput;
    update: VoiceUpdateInput;
  }) => VoicePromise;
  deleteVoice: (where: VoiceWhereUniqueInput) => VoicePromise;
  deleteManyVoices: (where?: VoiceWhereInput) => BatchPayloadPromise;
  createWeChat: (data: WeChatCreateInput) => WeChatPromise;
  updateWeChat: (args: {
    data: WeChatUpdateInput;
    where: WeChatWhereUniqueInput;
  }) => WeChatPromise;
  upsertWeChat: (args: {
    where: WeChatWhereUniqueInput;
    create: WeChatCreateInput;
    update: WeChatUpdateInput;
  }) => WeChatPromise;
  deleteWeChat: (where: WeChatWhereUniqueInput) => WeChatPromise;
  deleteManyWeChats: (where?: WeChatWhereInput) => BatchPayloadPromise;
  createWeChatUser: (data: WeChatUserCreateInput) => WeChatUserPromise;
  updateWeChatUser: (args: {
    data: WeChatUserUpdateInput;
    where: WeChatUserWhereUniqueInput;
  }) => WeChatUserPromise;
  updateManyWeChatUsers: (args: {
    data: WeChatUserUpdateManyMutationInput;
    where?: WeChatUserWhereInput;
  }) => BatchPayloadPromise;
  upsertWeChatUser: (args: {
    where: WeChatUserWhereUniqueInput;
    create: WeChatUserCreateInput;
    update: WeChatUserUpdateInput;
  }) => WeChatUserPromise;
  deleteWeChatUser: (where: WeChatUserWhereUniqueInput) => WeChatUserPromise;
  deleteManyWeChatUsers: (where?: WeChatUserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  app: (
    where?: AppSubscriptionWhereInput
  ) => AppSubscriptionPayloadSubscription;
  avatar: (
    where?: AvatarSubscriptionWhereInput
  ) => AvatarSubscriptionPayloadSubscription;
  chatRoom: (
    where?: ChatRoomSubscriptionWhereInput
  ) => ChatRoomSubscriptionPayloadSubscription;
  contact: (
    where?: ContactSubscriptionWhereInput
  ) => ContactSubscriptionPayloadSubscription;
  content: (
    where?: ContentSubscriptionWhereInput
  ) => ContentSubscriptionPayloadSubscription;
  file: (
    where?: FileSubscriptionWhereInput
  ) => FileSubscriptionPayloadSubscription;
  fileGroup: (
    where?: FileGroupSubscriptionWhereInput
  ) => FileGroupSubscriptionPayloadSubscription;
  fileIndex: (
    where?: FileIndexSubscriptionWhereInput
  ) => FileIndexSubscriptionPayloadSubscription;
  image: (
    where?: ImageSubscriptionWhereInput
  ) => ImageSubscriptionPayloadSubscription;
  message: (
    where?: MessageSubscriptionWhereInput
  ) => MessageSubscriptionPayloadSubscription;
  text: (
    where?: TextSubscriptionWhereInput
  ) => TextSubscriptionPayloadSubscription;
  url: (
    where?: UrlSubscriptionWhereInput
  ) => UrlSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  video: (
    where?: VideoSubscriptionWhereInput
  ) => VideoSubscriptionPayloadSubscription;
  voice: (
    where?: VoiceSubscriptionWhereInput
  ) => VoiceSubscriptionPayloadSubscription;
  weChat: (
    where?: WeChatSubscriptionWhereInput
  ) => WeChatSubscriptionPayloadSubscription;
  weChatUser: (
    where?: WeChatUserSubscriptionWhereInput
  ) => WeChatUserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type FileIndexOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "fileName_ASC"
  | "fileName_DESC"
  | "mimetype_ASC"
  | "mimetype_DESC"
  | "size_ASC"
  | "size_DESC";

export type AppOrderByInput = "id_ASC" | "id_DESC" | "xml_ASC" | "xml_DESC";

export type FileOrderByInput = "id_ASC" | "id_DESC" | "size_ASC" | "size_DESC";

export type VoiceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "voiceLength_ASC"
  | "voiceLength_DESC";

export type UrlOrderByInput = "id_ASC" | "id_DESC" | "url_ASC" | "url_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "name_ASC"
  | "name_DESC"
  | "password_ASC"
  | "password_DESC";

export type ContentOrderByInput = "id_ASC" | "id_DESC";

export type TextOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "textMsg_ASC"
  | "textMsg_DESC";

export type ContactOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC";

export type FileGroupOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type AvatarOrderByInput = "id_ASC" | "id_DESC";

export type MessageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "msgSvrId_ASC"
  | "msgSvrId_DESC"
  | "isSend_ASC"
  | "isSend_DESC"
  | "type_ASC"
  | "type_DESC"
  | "createTime_ASC"
  | "createTime_DESC";

export type ChatRoomOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "username_ASC"
  | "username_DESC"
  | "nickname_ASC"
  | "nickname_DESC"
  | "displayName_ASC"
  | "displayName_DESC"
  | "modifyTime_ASC"
  | "modifyTime_DESC";

export type WeChatUserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "username_ASC"
  | "username_DESC"
  | "alias_ASC"
  | "alias_DESC"
  | "conRemark_ASC"
  | "conRemark_DESC"
  | "nickname_ASC"
  | "nickname_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ImageOrderByInput = "id_ASC" | "id_DESC";

export type WeChatOrderByInput = "id_ASC" | "id_DESC";

export type VideoOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "videolength_ASC"
  | "videolength_DESC";

export interface ContactCreateWithoutWeChatUserInput {
  id?: Maybe<ID_Input>;
  type: String;
}

export type AppWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AvatarUpsertNestedInput {
  update: AvatarUpdateDataInput;
  create: AvatarCreateInput;
}

export interface ImageWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  thumbnailImg?: Maybe<FileIndexWhereInput>;
  bigImg?: Maybe<FileIndexWhereInput>;
  content?: Maybe<ContentWhereInput>;
  AND?: Maybe<ImageWhereInput[] | ImageWhereInput>;
}

export interface MessageUpdateManyWithoutTalkerInput {
  create?: Maybe<
    MessageCreateWithoutTalkerInput[] | MessageCreateWithoutTalkerInput
  >;
  delete?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  connect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  set?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  disconnect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  update?: Maybe<
    | MessageUpdateWithWhereUniqueWithoutTalkerInput[]
    | MessageUpdateWithWhereUniqueWithoutTalkerInput
  >;
  upsert?: Maybe<
    | MessageUpsertWithWhereUniqueWithoutTalkerInput[]
    | MessageUpsertWithWhereUniqueWithoutTalkerInput
  >;
  deleteMany?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
  updateMany?: Maybe<
    | MessageUpdateManyWithWhereNestedInput[]
    | MessageUpdateManyWithWhereNestedInput
  >;
}

export interface VideoWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  fileName?: Maybe<FileIndexWhereInput>;
  thumbnailImg?: Maybe<FileIndexWhereInput>;
  videolength?: Maybe<Int>;
  videolength_not?: Maybe<Int>;
  videolength_in?: Maybe<Int[] | Int>;
  videolength_not_in?: Maybe<Int[] | Int>;
  videolength_lt?: Maybe<Int>;
  videolength_lte?: Maybe<Int>;
  videolength_gt?: Maybe<Int>;
  videolength_gte?: Maybe<Int>;
  content?: Maybe<ContentWhereInput>;
  AND?: Maybe<VideoWhereInput[] | VideoWhereInput>;
}

export interface MessageUpdateWithWhereUniqueWithoutTalkerInput {
  where: MessageWhereUniqueInput;
  data: MessageUpdateWithoutTalkerDataInput;
}

export interface TextWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  textMsg?: Maybe<String>;
  textMsg_not?: Maybe<String>;
  textMsg_in?: Maybe<String[] | String>;
  textMsg_not_in?: Maybe<String[] | String>;
  textMsg_lt?: Maybe<String>;
  textMsg_lte?: Maybe<String>;
  textMsg_gt?: Maybe<String>;
  textMsg_gte?: Maybe<String>;
  textMsg_contains?: Maybe<String>;
  textMsg_not_contains?: Maybe<String>;
  textMsg_starts_with?: Maybe<String>;
  textMsg_not_starts_with?: Maybe<String>;
  textMsg_ends_with?: Maybe<String>;
  textMsg_not_ends_with?: Maybe<String>;
  content?: Maybe<ContentWhereInput>;
  AND?: Maybe<TextWhereInput[] | TextWhereInput>;
}

export interface VoiceUpsertWithoutContentInput {
  update: VoiceUpdateWithoutContentDataInput;
  create: VoiceCreateWithoutContentInput;
}

export interface MessageUpdateManyMutationInput {
  msgSvrId?: Maybe<String>;
  isSend?: Maybe<Int>;
  type?: Maybe<Int>;
  createTime?: Maybe<DateTimeInput>;
}

export interface VideoUpdateOneWithoutContentInput {
  create?: Maybe<VideoCreateWithoutContentInput>;
  update?: Maybe<VideoUpdateWithoutContentDataInput>;
  upsert?: Maybe<VideoUpsertWithoutContentInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<VideoWhereUniqueInput>;
}

export interface MessageUpdateWithoutTalkerDataInput {
  msgSvrId?: Maybe<String>;
  isSend?: Maybe<Int>;
  type?: Maybe<Int>;
  createTime?: Maybe<DateTimeInput>;
  chatRoom?: Maybe<ChatRoomUpdateOneWithoutMessageInput>;
  content?: Maybe<ContentUpdateOneInput>;
}

export interface VideoUpdateWithoutContentDataInput {
  fileName?: Maybe<FileIndexUpdateOneInput>;
  thumbnailImg?: Maybe<FileIndexUpdateOneInput>;
  videolength?: Maybe<Int>;
}

export interface WeChatSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<WeChatWhereInput>;
  AND?: Maybe<WeChatSubscriptionWhereInput[] | WeChatSubscriptionWhereInput>;
}

export interface VideoUpsertWithoutContentInput {
  update: VideoUpdateWithoutContentDataInput;
  create: VideoCreateWithoutContentInput;
}

export interface VoiceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<VoiceWhereInput>;
  AND?: Maybe<VoiceSubscriptionWhereInput[] | VoiceSubscriptionWhereInput>;
}

export interface FileUpdateOneWithoutContentInput {
  create?: Maybe<FileCreateWithoutContentInput>;
  update?: Maybe<FileUpdateWithoutContentDataInput>;
  upsert?: Maybe<FileUpsertWithoutContentInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<FileWhereUniqueInput>;
}

export interface ContentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  text?: Maybe<TextWhereInput>;
  image?: Maybe<ImageWhereInput>;
  voice?: Maybe<VoiceWhereInput>;
  video?: Maybe<VideoWhereInput>;
  file?: Maybe<FileWhereInput>;
  app?: Maybe<AppWhereInput>;
  AND?: Maybe<ContentWhereInput[] | ContentWhereInput>;
}

export interface FileUpdateWithoutContentDataInput {
  fileName?: Maybe<FileIndexUpdateOneInput>;
  size?: Maybe<Int>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface FileUpsertWithoutContentInput {
  update: FileUpdateWithoutContentDataInput;
  create: FileCreateWithoutContentInput;
}

export type ChatRoomWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  username?: Maybe<String>;
}>;

export interface ContentUpsertWithoutAppInput {
  update: ContentUpdateWithoutAppDataInput;
  create: ContentCreateWithoutAppInput;
}

export interface MessageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MessageWhereInput>;
  AND?: Maybe<MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput>;
}

export interface AppUpdateManyMutationInput {
  xml?: Maybe<Json>;
}

export interface WeChatUserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  alias?: Maybe<String>;
  alias_not?: Maybe<String>;
  alias_in?: Maybe<String[] | String>;
  alias_not_in?: Maybe<String[] | String>;
  alias_lt?: Maybe<String>;
  alias_lte?: Maybe<String>;
  alias_gt?: Maybe<String>;
  alias_gte?: Maybe<String>;
  alias_contains?: Maybe<String>;
  alias_not_contains?: Maybe<String>;
  alias_starts_with?: Maybe<String>;
  alias_not_starts_with?: Maybe<String>;
  alias_ends_with?: Maybe<String>;
  alias_not_ends_with?: Maybe<String>;
  conRemark?: Maybe<String>;
  conRemark_not?: Maybe<String>;
  conRemark_in?: Maybe<String[] | String>;
  conRemark_not_in?: Maybe<String[] | String>;
  conRemark_lt?: Maybe<String>;
  conRemark_lte?: Maybe<String>;
  conRemark_gt?: Maybe<String>;
  conRemark_gte?: Maybe<String>;
  conRemark_contains?: Maybe<String>;
  conRemark_not_contains?: Maybe<String>;
  conRemark_starts_with?: Maybe<String>;
  conRemark_not_starts_with?: Maybe<String>;
  conRemark_ends_with?: Maybe<String>;
  conRemark_not_ends_with?: Maybe<String>;
  nickname?: Maybe<String>;
  nickname_not?: Maybe<String>;
  nickname_in?: Maybe<String[] | String>;
  nickname_not_in?: Maybe<String[] | String>;
  nickname_lt?: Maybe<String>;
  nickname_lte?: Maybe<String>;
  nickname_gt?: Maybe<String>;
  nickname_gte?: Maybe<String>;
  nickname_contains?: Maybe<String>;
  nickname_not_contains?: Maybe<String>;
  nickname_starts_with?: Maybe<String>;
  nickname_not_starts_with?: Maybe<String>;
  nickname_ends_with?: Maybe<String>;
  nickname_not_ends_with?: Maybe<String>;
  avatar?: Maybe<AvatarWhereInput>;
  message_some?: Maybe<MessageWhereInput>;
  haveChatRoom_some?: Maybe<ChatRoomWhereInput>;
  joinChatRoom_some?: Maybe<ChatRoomWhereInput>;
  contact?: Maybe<ContactWhereInput>;
  AND?: Maybe<WeChatUserWhereInput[] | WeChatUserWhereInput>;
}

export interface ContentUpdateOneWithoutTextInput {
  create?: Maybe<ContentCreateWithoutTextInput>;
  update?: Maybe<ContentUpdateWithoutTextDataInput>;
  upsert?: Maybe<ContentUpsertWithoutTextInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ContentWhereUniqueInput>;
}

export interface ImageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ImageWhereInput>;
  AND?: Maybe<ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput>;
}

export interface TextUpdateInput {
  textMsg?: Maybe<String>;
  content?: Maybe<ContentUpdateOneWithoutTextInput>;
}

export interface AppWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  content?: Maybe<ContentWhereInput>;
  AND?: Maybe<AppWhereInput[] | AppWhereInput>;
}

export interface AvatarCreateInput {
  id?: Maybe<ID_Input>;
  thumbnailImg?: Maybe<UrlCreateOneInput>;
  bigImg?: Maybe<UrlCreateOneInput>;
}

export interface FileGroupSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FileGroupWhereInput>;
  AND?: Maybe<
    FileGroupSubscriptionWhereInput[] | FileGroupSubscriptionWhereInput
  >;
}

export interface UrlCreateOneInput {
  create?: Maybe<UrlCreateInput>;
  connect?: Maybe<UrlWhereUniqueInput>;
}

export interface ContentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ContentWhereInput>;
  AND?: Maybe<ContentSubscriptionWhereInput[] | ContentSubscriptionWhereInput>;
}

export interface UrlCreateInput {
  id?: Maybe<ID_Input>;
  url: String;
  fileIndex?: Maybe<FileIndexCreateOneWithoutUrlsInput>;
}

export interface ChatRoomSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ChatRoomWhereInput>;
  AND?: Maybe<
    ChatRoomSubscriptionWhereInput[] | ChatRoomSubscriptionWhereInput
  >;
}

export interface FileIndexCreateOneWithoutUrlsInput {
  create?: Maybe<FileIndexCreateWithoutUrlsInput>;
  connect?: Maybe<FileIndexWhereUniqueInput>;
}

export type ContactWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface FileIndexCreateWithoutUrlsInput {
  id?: Maybe<ID_Input>;
  fileName: String;
  mimetype: String;
  size: Int;
}

export interface WeChatUserUpdateManyMutationInput {
  username?: Maybe<String>;
  alias?: Maybe<String>;
  conRemark?: Maybe<String>;
  nickname?: Maybe<String>;
}

export interface AvatarUpdateInput {
  thumbnailImg?: Maybe<UrlUpdateOneInput>;
  bigImg?: Maybe<UrlUpdateOneInput>;
}

export interface WeChatUpdateInput {
  weChatOwner?: Maybe<WeChatUserUpdateOneRequiredInput>;
  weChatUsers?: Maybe<WeChatUserUpdateManyInput>;
  chatRooms?: Maybe<ChatRoomUpdateManyInput>;
  messages?: Maybe<MessageUpdateManyInput>;
}

export interface UrlUpdateOneInput {
  create?: Maybe<UrlCreateInput>;
  update?: Maybe<UrlUpdateDataInput>;
  upsert?: Maybe<UrlUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UrlWhereUniqueInput>;
}

export interface VoiceUpdateManyMutationInput {
  voiceLength?: Maybe<Int>;
}

export interface UrlUpdateDataInput {
  url?: Maybe<String>;
  fileIndex?: Maybe<FileIndexUpdateOneWithoutUrlsInput>;
}

export interface ContentUpdateWithoutVoiceDataInput {
  text?: Maybe<TextUpdateOneWithoutContentInput>;
  image?: Maybe<ImageUpdateOneWithoutContentInput>;
  video?: Maybe<VideoUpdateOneWithoutContentInput>;
  file?: Maybe<FileUpdateOneWithoutContentInput>;
  app?: Maybe<AppUpdateOneWithoutContentInput>;
}

export interface FileIndexUpdateOneWithoutUrlsInput {
  create?: Maybe<FileIndexCreateWithoutUrlsInput>;
  update?: Maybe<FileIndexUpdateWithoutUrlsDataInput>;
  upsert?: Maybe<FileIndexUpsertWithoutUrlsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<FileIndexWhereUniqueInput>;
}

export type FileWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface FileIndexUpdateWithoutUrlsDataInput {
  fileName?: Maybe<String>;
  mimetype?: Maybe<String>;
  size?: Maybe<Int>;
}

export interface VoiceUpdateInput {
  fileName?: Maybe<FileIndexUpdateOneInput>;
  voiceLength?: Maybe<Int>;
  content?: Maybe<ContentUpdateOneWithoutVoiceInput>;
}

export interface FileIndexUpsertWithoutUrlsInput {
  update: FileIndexUpdateWithoutUrlsDataInput;
  create: FileIndexCreateWithoutUrlsInput;
}

export interface ContentCreateOneWithoutVoiceInput {
  create?: Maybe<ContentCreateWithoutVoiceInput>;
  connect?: Maybe<ContentWhereUniqueInput>;
}

export interface UrlUpsertNestedInput {
  update: UrlUpdateDataInput;
  create: UrlCreateInput;
}

export interface VoiceCreateInput {
  id?: Maybe<ID_Input>;
  fileName?: Maybe<FileIndexCreateOneInput>;
  voiceLength?: Maybe<Int>;
  content?: Maybe<ContentCreateOneWithoutVoiceInput>;
}

export interface ChatRoomCreateInput {
  id?: Maybe<ID_Input>;
  username: String;
  nickname?: Maybe<String>;
  displayName?: Maybe<String>;
  owner?: Maybe<WeChatUserCreateOneWithoutHaveChatRoomInput>;
  memberList?: Maybe<WeChatUserCreateManyWithoutJoinChatRoomInput>;
  modifyTime?: Maybe<DateTimeInput>;
  avatar?: Maybe<AvatarCreateOneInput>;
  message?: Maybe<MessageCreateManyWithoutChatRoomInput>;
}

export interface FileGroupWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  fileIndexes_some?: Maybe<FileIndexWhereInput>;
  AND?: Maybe<FileGroupWhereInput[] | FileGroupWhereInput>;
}

export interface WeChatUserCreateOneWithoutHaveChatRoomInput {
  create?: Maybe<WeChatUserCreateWithoutHaveChatRoomInput>;
  connect?: Maybe<WeChatUserWhereUniqueInput>;
}

export interface ContentUpsertWithoutVideoInput {
  update: ContentUpdateWithoutVideoDataInput;
  create: ContentCreateWithoutVideoInput;
}

export interface WeChatUserCreateWithoutHaveChatRoomInput {
  id?: Maybe<ID_Input>;
  username: String;
  alias?: Maybe<String>;
  conRemark?: Maybe<String>;
  nickname?: Maybe<String>;
  avatar?: Maybe<AvatarCreateOneInput>;
  message?: Maybe<MessageCreateManyWithoutTalkerInput>;
  joinChatRoom?: Maybe<ChatRoomCreateManyWithoutMemberListInput>;
  contact?: Maybe<ContactCreateOneWithoutWeChatUserInput>;
}

export interface ContentUpdateOneWithoutVideoInput {
  create?: Maybe<ContentCreateWithoutVideoInput>;
  update?: Maybe<ContentUpdateWithoutVideoDataInput>;
  upsert?: Maybe<ContentUpsertWithoutVideoInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ContentWhereUniqueInput>;
}

export interface AvatarCreateOneInput {
  create?: Maybe<AvatarCreateInput>;
  connect?: Maybe<AvatarWhereUniqueInput>;
}

export interface VideoUpdateInput {
  fileName?: Maybe<FileIndexUpdateOneInput>;
  thumbnailImg?: Maybe<FileIndexUpdateOneInput>;
  videolength?: Maybe<Int>;
  content?: Maybe<ContentUpdateOneWithoutVideoInput>;
}

export interface MessageCreateManyWithoutTalkerInput {
  create?: Maybe<
    MessageCreateWithoutTalkerInput[] | MessageCreateWithoutTalkerInput
  >;
  connect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
}

export interface ContentCreateOneWithoutVideoInput {
  create?: Maybe<ContentCreateWithoutVideoInput>;
  connect?: Maybe<ContentWhereUniqueInput>;
}

export interface MessageCreateWithoutTalkerInput {
  id?: Maybe<ID_Input>;
  msgSvrId?: Maybe<String>;
  isSend?: Maybe<Int>;
  type?: Maybe<Int>;
  createTime?: Maybe<DateTimeInput>;
  chatRoom?: Maybe<ChatRoomCreateOneWithoutMessageInput>;
  content?: Maybe<ContentCreateOneInput>;
}

export interface VideoCreateInput {
  id?: Maybe<ID_Input>;
  fileName?: Maybe<FileIndexCreateOneInput>;
  thumbnailImg?: Maybe<FileIndexCreateOneInput>;
  videolength?: Maybe<Int>;
  content?: Maybe<ContentCreateOneWithoutVideoInput>;
}

export interface ChatRoomCreateOneWithoutMessageInput {
  create?: Maybe<ChatRoomCreateWithoutMessageInput>;
  connect?: Maybe<ChatRoomWhereUniqueInput>;
}

export interface WeChatScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  AND?: Maybe<WeChatScalarWhereInput[] | WeChatScalarWhereInput>;
  OR?: Maybe<WeChatScalarWhereInput[] | WeChatScalarWhereInput>;
  NOT?: Maybe<WeChatScalarWhereInput[] | WeChatScalarWhereInput>;
}

export interface ChatRoomCreateWithoutMessageInput {
  id?: Maybe<ID_Input>;
  username: String;
  nickname?: Maybe<String>;
  displayName?: Maybe<String>;
  owner?: Maybe<WeChatUserCreateOneWithoutHaveChatRoomInput>;
  memberList?: Maybe<WeChatUserCreateManyWithoutJoinChatRoomInput>;
  modifyTime?: Maybe<DateTimeInput>;
  avatar?: Maybe<AvatarCreateOneInput>;
}

export type MessageWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface WeChatUserCreateManyWithoutJoinChatRoomInput {
  create?: Maybe<
    | WeChatUserCreateWithoutJoinChatRoomInput[]
    | WeChatUserCreateWithoutJoinChatRoomInput
  >;
  connect?: Maybe<WeChatUserWhereUniqueInput[] | WeChatUserWhereUniqueInput>;
}

export interface MessageUpdateDataInput {
  msgSvrId?: Maybe<String>;
  isSend?: Maybe<Int>;
  type?: Maybe<Int>;
  talker?: Maybe<WeChatUserUpdateOneWithoutMessageInput>;
  createTime?: Maybe<DateTimeInput>;
  chatRoom?: Maybe<ChatRoomUpdateOneWithoutMessageInput>;
  content?: Maybe<ContentUpdateOneInput>;
}

export interface WeChatUserCreateWithoutJoinChatRoomInput {
  id?: Maybe<ID_Input>;
  username: String;
  alias?: Maybe<String>;
  conRemark?: Maybe<String>;
  nickname?: Maybe<String>;
  avatar?: Maybe<AvatarCreateOneInput>;
  message?: Maybe<MessageCreateManyWithoutTalkerInput>;
  haveChatRoom?: Maybe<ChatRoomCreateManyWithoutOwnerInput>;
  contact?: Maybe<ContactCreateOneWithoutWeChatUserInput>;
}

export type TextWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ChatRoomCreateManyWithoutOwnerInput {
  create?: Maybe<
    ChatRoomCreateWithoutOwnerInput[] | ChatRoomCreateWithoutOwnerInput
  >;
  connect?: Maybe<ChatRoomWhereUniqueInput[] | ChatRoomWhereUniqueInput>;
}

export interface ChatRoomUpsertWithWhereUniqueNestedInput {
  where: ChatRoomWhereUniqueInput;
  update: ChatRoomUpdateDataInput;
  create: ChatRoomCreateInput;
}

export interface ChatRoomCreateWithoutOwnerInput {
  id?: Maybe<ID_Input>;
  username: String;
  nickname?: Maybe<String>;
  displayName?: Maybe<String>;
  memberList?: Maybe<WeChatUserCreateManyWithoutJoinChatRoomInput>;
  modifyTime?: Maybe<DateTimeInput>;
  avatar?: Maybe<AvatarCreateOneInput>;
  message?: Maybe<MessageCreateManyWithoutChatRoomInput>;
}

export interface ChatRoomUpdateWithWhereUniqueNestedInput {
  where: ChatRoomWhereUniqueInput;
  data: ChatRoomUpdateDataInput;
}

export interface MessageCreateManyWithoutChatRoomInput {
  create?: Maybe<
    MessageCreateWithoutChatRoomInput[] | MessageCreateWithoutChatRoomInput
  >;
  connect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
}

export interface ChatRoomUpdateManyInput {
  create?: Maybe<ChatRoomCreateInput[] | ChatRoomCreateInput>;
  update?: Maybe<
    | ChatRoomUpdateWithWhereUniqueNestedInput[]
    | ChatRoomUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ChatRoomUpsertWithWhereUniqueNestedInput[]
    | ChatRoomUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<ChatRoomWhereUniqueInput[] | ChatRoomWhereUniqueInput>;
  connect?: Maybe<ChatRoomWhereUniqueInput[] | ChatRoomWhereUniqueInput>;
  set?: Maybe<ChatRoomWhereUniqueInput[] | ChatRoomWhereUniqueInput>;
  disconnect?: Maybe<ChatRoomWhereUniqueInput[] | ChatRoomWhereUniqueInput>;
  deleteMany?: Maybe<ChatRoomScalarWhereInput[] | ChatRoomScalarWhereInput>;
  updateMany?: Maybe<
    | ChatRoomUpdateManyWithWhereNestedInput[]
    | ChatRoomUpdateManyWithWhereNestedInput
  >;
}

export interface MessageCreateWithoutChatRoomInput {
  id?: Maybe<ID_Input>;
  msgSvrId?: Maybe<String>;
  isSend?: Maybe<Int>;
  type?: Maybe<Int>;
  talker?: Maybe<WeChatUserCreateOneWithoutMessageInput>;
  createTime?: Maybe<DateTimeInput>;
  content?: Maybe<ContentCreateOneInput>;
}

export interface WeChatUserUpdateWithWhereUniqueNestedInput {
  where: WeChatUserWhereUniqueInput;
  data: WeChatUserUpdateDataInput;
}

export interface WeChatUserCreateOneWithoutMessageInput {
  create?: Maybe<WeChatUserCreateWithoutMessageInput>;
  connect?: Maybe<WeChatUserWhereUniqueInput>;
}

export interface WeChatUserUpdateManyInput {
  create?: Maybe<WeChatUserCreateInput[] | WeChatUserCreateInput>;
  update?: Maybe<
    | WeChatUserUpdateWithWhereUniqueNestedInput[]
    | WeChatUserUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | WeChatUserUpsertWithWhereUniqueNestedInput[]
    | WeChatUserUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<WeChatUserWhereUniqueInput[] | WeChatUserWhereUniqueInput>;
  connect?: Maybe<WeChatUserWhereUniqueInput[] | WeChatUserWhereUniqueInput>;
  set?: Maybe<WeChatUserWhereUniqueInput[] | WeChatUserWhereUniqueInput>;
  disconnect?: Maybe<WeChatUserWhereUniqueInput[] | WeChatUserWhereUniqueInput>;
  deleteMany?: Maybe<WeChatUserScalarWhereInput[] | WeChatUserScalarWhereInput>;
  updateMany?: Maybe<
    | WeChatUserUpdateManyWithWhereNestedInput[]
    | WeChatUserUpdateManyWithWhereNestedInput
  >;
}

export interface WeChatUserCreateWithoutMessageInput {
  id?: Maybe<ID_Input>;
  username: String;
  alias?: Maybe<String>;
  conRemark?: Maybe<String>;
  nickname?: Maybe<String>;
  avatar?: Maybe<AvatarCreateOneInput>;
  haveChatRoom?: Maybe<ChatRoomCreateManyWithoutOwnerInput>;
  joinChatRoom?: Maybe<ChatRoomCreateManyWithoutMemberListInput>;
  contact?: Maybe<ContactCreateOneWithoutWeChatUserInput>;
}

export interface WeChatUserUpsertNestedInput {
  update: WeChatUserUpdateDataInput;
  create: WeChatUserCreateInput;
}

export interface ChatRoomCreateManyWithoutMemberListInput {
  create?: Maybe<
    | ChatRoomCreateWithoutMemberListInput[]
    | ChatRoomCreateWithoutMemberListInput
  >;
  connect?: Maybe<ChatRoomWhereUniqueInput[] | ChatRoomWhereUniqueInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  weChat_some?: Maybe<WeChatWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface ChatRoomCreateWithoutMemberListInput {
  id?: Maybe<ID_Input>;
  username: String;
  nickname?: Maybe<String>;
  displayName?: Maybe<String>;
  owner?: Maybe<WeChatUserCreateOneWithoutHaveChatRoomInput>;
  modifyTime?: Maybe<DateTimeInput>;
  avatar?: Maybe<AvatarCreateOneInput>;
  message?: Maybe<MessageCreateManyWithoutChatRoomInput>;
}

export interface WeChatUpdateDataInput {
  weChatOwner?: Maybe<WeChatUserUpdateOneRequiredInput>;
  weChatUsers?: Maybe<WeChatUserUpdateManyInput>;
  chatRooms?: Maybe<ChatRoomUpdateManyInput>;
  messages?: Maybe<MessageUpdateManyInput>;
}

export interface ContactCreateOneWithoutWeChatUserInput {
  create?: Maybe<ContactCreateWithoutWeChatUserInput>;
  connect?: Maybe<ContactWhereUniqueInput>;
}

export interface WeChatUpdateManyInput {
  create?: Maybe<WeChatCreateInput[] | WeChatCreateInput>;
  update?: Maybe<
    | WeChatUpdateWithWhereUniqueNestedInput[]
    | WeChatUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | WeChatUpsertWithWhereUniqueNestedInput[]
    | WeChatUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<WeChatWhereUniqueInput[] | WeChatWhereUniqueInput>;
  connect?: Maybe<WeChatWhereUniqueInput[] | WeChatWhereUniqueInput>;
  set?: Maybe<WeChatWhereUniqueInput[] | WeChatWhereUniqueInput>;
  disconnect?: Maybe<WeChatWhereUniqueInput[] | WeChatWhereUniqueInput>;
  deleteMany?: Maybe<WeChatScalarWhereInput[] | WeChatScalarWhereInput>;
}

export interface ContentCreateWithoutTextInput {
  id?: Maybe<ID_Input>;
  image?: Maybe<ImageCreateOneWithoutContentInput>;
  voice?: Maybe<VoiceCreateOneWithoutContentInput>;
  video?: Maybe<VideoCreateOneWithoutContentInput>;
  file?: Maybe<FileCreateOneWithoutContentInput>;
  app?: Maybe<AppCreateOneWithoutContentInput>;
}

export interface UserUpdateInput {
  email?: Maybe<String>;
  name?: Maybe<String>;
  password?: Maybe<String>;
  weChat?: Maybe<WeChatUpdateManyInput>;
}

export interface ContentCreateOneInput {
  create?: Maybe<ContentCreateInput>;
  connect?: Maybe<ContentWhereUniqueInput>;
}

export interface ChatRoomCreateManyInput {
  create?: Maybe<ChatRoomCreateInput[] | ChatRoomCreateInput>;
  connect?: Maybe<ChatRoomWhereUniqueInput[] | ChatRoomWhereUniqueInput>;
}

export interface ContentCreateInput {
  id?: Maybe<ID_Input>;
  text?: Maybe<TextCreateOneWithoutContentInput>;
  image?: Maybe<ImageCreateOneWithoutContentInput>;
  voice?: Maybe<VoiceCreateOneWithoutContentInput>;
  video?: Maybe<VideoCreateOneWithoutContentInput>;
  file?: Maybe<FileCreateOneWithoutContentInput>;
  app?: Maybe<AppCreateOneWithoutContentInput>;
}

export type VoiceWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AppCreateOneWithoutContentInput {
  create?: Maybe<AppCreateWithoutContentInput>;
  connect?: Maybe<AppWhereUniqueInput>;
}

export interface WeChatUserCreateOneInput {
  create?: Maybe<WeChatUserCreateInput>;
  connect?: Maybe<WeChatUserWhereUniqueInput>;
}

export interface AppCreateWithoutContentInput {
  id?: Maybe<ID_Input>;
  xml?: Maybe<Json>;
}

export interface WeChatCreateManyInput {
  create?: Maybe<WeChatCreateInput[] | WeChatCreateInput>;
  connect?: Maybe<WeChatWhereUniqueInput[] | WeChatWhereUniqueInput>;
}

export interface ChatRoomUpdateInput {
  username?: Maybe<String>;
  nickname?: Maybe<String>;
  displayName?: Maybe<String>;
  owner?: Maybe<WeChatUserUpdateOneWithoutHaveChatRoomInput>;
  memberList?: Maybe<WeChatUserUpdateManyWithoutJoinChatRoomInput>;
  modifyTime?: Maybe<DateTimeInput>;
  avatar?: Maybe<AvatarUpdateOneInput>;
  message?: Maybe<MessageUpdateManyWithoutChatRoomInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  email: String;
  name: String;
  password: String;
  weChat?: Maybe<WeChatCreateManyInput>;
}

export interface WeChatUserUpdateOneWithoutHaveChatRoomInput {
  create?: Maybe<WeChatUserCreateWithoutHaveChatRoomInput>;
  update?: Maybe<WeChatUserUpdateWithoutHaveChatRoomDataInput>;
  upsert?: Maybe<WeChatUserUpsertWithoutHaveChatRoomInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<WeChatUserWhereUniqueInput>;
}

export interface UrlUpdateInput {
  url?: Maybe<String>;
  fileIndex?: Maybe<FileIndexUpdateOneWithoutUrlsInput>;
}

export interface WeChatUserUpdateWithoutHaveChatRoomDataInput {
  username?: Maybe<String>;
  alias?: Maybe<String>;
  conRemark?: Maybe<String>;
  nickname?: Maybe<String>;
  avatar?: Maybe<AvatarUpdateOneInput>;
  message?: Maybe<MessageUpdateManyWithoutTalkerInput>;
  joinChatRoom?: Maybe<ChatRoomUpdateManyWithoutMemberListInput>;
  contact?: Maybe<ContactUpdateOneWithoutWeChatUserInput>;
}

export interface TextUpdateManyMutationInput {
  textMsg?: Maybe<String>;
}

export interface AvatarUpdateOneInput {
  create?: Maybe<AvatarCreateInput>;
  update?: Maybe<AvatarUpdateDataInput>;
  upsert?: Maybe<AvatarUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<AvatarWhereUniqueInput>;
}

export interface ContentUpdateWithoutTextDataInput {
  image?: Maybe<ImageUpdateOneWithoutContentInput>;
  voice?: Maybe<VoiceUpdateOneWithoutContentInput>;
  video?: Maybe<VideoUpdateOneWithoutContentInput>;
  file?: Maybe<FileUpdateOneWithoutContentInput>;
  app?: Maybe<AppUpdateOneWithoutContentInput>;
}

export interface AvatarUpdateDataInput {
  thumbnailImg?: Maybe<UrlUpdateOneInput>;
  bigImg?: Maybe<UrlUpdateOneInput>;
}

export interface AppCreateInput {
  id?: Maybe<ID_Input>;
  xml?: Maybe<Json>;
  content?: Maybe<ContentCreateOneWithoutAppInput>;
}

export interface VoiceWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  fileName?: Maybe<FileIndexWhereInput>;
  voiceLength?: Maybe<Int>;
  voiceLength_not?: Maybe<Int>;
  voiceLength_in?: Maybe<Int[] | Int>;
  voiceLength_not_in?: Maybe<Int[] | Int>;
  voiceLength_lt?: Maybe<Int>;
  voiceLength_lte?: Maybe<Int>;
  voiceLength_gt?: Maybe<Int>;
  voiceLength_gte?: Maybe<Int>;
  content?: Maybe<ContentWhereInput>;
  AND?: Maybe<VoiceWhereInput[] | VoiceWhereInput>;
}

export interface ContentCreateWithoutAppInput {
  id?: Maybe<ID_Input>;
  text?: Maybe<TextCreateOneWithoutContentInput>;
  image?: Maybe<ImageCreateOneWithoutContentInput>;
  voice?: Maybe<VoiceCreateOneWithoutContentInput>;
  video?: Maybe<VideoCreateOneWithoutContentInput>;
  file?: Maybe<FileCreateOneWithoutContentInput>;
}

export interface FileWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  fileName?: Maybe<FileIndexWhereInput>;
  size?: Maybe<Int>;
  size_not?: Maybe<Int>;
  size_in?: Maybe<Int[] | Int>;
  size_not_in?: Maybe<Int[] | Int>;
  size_lt?: Maybe<Int>;
  size_lte?: Maybe<Int>;
  size_gt?: Maybe<Int>;
  size_gte?: Maybe<Int>;
  content?: Maybe<ContentWhereInput>;
  AND?: Maybe<FileWhereInput[] | FileWhereInput>;
}

export interface TextCreateWithoutContentInput {
  id?: Maybe<ID_Input>;
  textMsg: String;
}

export interface ContentCreateOneWithoutTextInput {
  create?: Maybe<ContentCreateWithoutTextInput>;
  connect?: Maybe<ContentWhereUniqueInput>;
}

export interface ImageCreateWithoutContentInput {
  id?: Maybe<ID_Input>;
  thumbnailImg?: Maybe<FileIndexCreateOneInput>;
  bigImg?: Maybe<FileIndexCreateOneInput>;
}

export interface TextCreateInput {
  id?: Maybe<ID_Input>;
  textMsg: String;
  content?: Maybe<ContentCreateOneWithoutTextInput>;
}

export interface FileIndexCreateInput {
  id?: Maybe<ID_Input>;
  fileName: String;
  mimetype: String;
  size: Int;
  urls?: Maybe<UrlCreateManyWithoutFileIndexInput>;
}

export interface ChatRoomUpdateOneWithoutMessageInput {
  create?: Maybe<ChatRoomCreateWithoutMessageInput>;
  update?: Maybe<ChatRoomUpdateWithoutMessageDataInput>;
  upsert?: Maybe<ChatRoomUpsertWithoutMessageInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ChatRoomWhereUniqueInput>;
}

export interface UrlCreateWithoutFileIndexInput {
  id?: Maybe<ID_Input>;
  url: String;
}

export interface ChatRoomUpdateWithoutMessageDataInput {
  username?: Maybe<String>;
  nickname?: Maybe<String>;
  displayName?: Maybe<String>;
  owner?: Maybe<WeChatUserUpdateOneWithoutHaveChatRoomInput>;
  memberList?: Maybe<WeChatUserUpdateManyWithoutJoinChatRoomInput>;
  modifyTime?: Maybe<DateTimeInput>;
  avatar?: Maybe<AvatarUpdateOneInput>;
}

export interface VoiceCreateWithoutContentInput {
  id?: Maybe<ID_Input>;
  fileName?: Maybe<FileIndexCreateOneInput>;
  voiceLength?: Maybe<Int>;
}

export interface WeChatUserUpdateManyWithoutJoinChatRoomInput {
  create?: Maybe<
    | WeChatUserCreateWithoutJoinChatRoomInput[]
    | WeChatUserCreateWithoutJoinChatRoomInput
  >;
  delete?: Maybe<WeChatUserWhereUniqueInput[] | WeChatUserWhereUniqueInput>;
  connect?: Maybe<WeChatUserWhereUniqueInput[] | WeChatUserWhereUniqueInput>;
  set?: Maybe<WeChatUserWhereUniqueInput[] | WeChatUserWhereUniqueInput>;
  disconnect?: Maybe<WeChatUserWhereUniqueInput[] | WeChatUserWhereUniqueInput>;
  update?: Maybe<
    | WeChatUserUpdateWithWhereUniqueWithoutJoinChatRoomInput[]
    | WeChatUserUpdateWithWhereUniqueWithoutJoinChatRoomInput
  >;
  upsert?: Maybe<
    | WeChatUserUpsertWithWhereUniqueWithoutJoinChatRoomInput[]
    | WeChatUserUpsertWithWhereUniqueWithoutJoinChatRoomInput
  >;
  deleteMany?: Maybe<WeChatUserScalarWhereInput[] | WeChatUserScalarWhereInput>;
  updateMany?: Maybe<
    | WeChatUserUpdateManyWithWhereNestedInput[]
    | WeChatUserUpdateManyWithWhereNestedInput
  >;
}

export interface VideoCreateWithoutContentInput {
  id?: Maybe<ID_Input>;
  fileName?: Maybe<FileIndexCreateOneInput>;
  thumbnailImg?: Maybe<FileIndexCreateOneInput>;
  videolength?: Maybe<Int>;
}

export interface WeChatUserUpdateWithWhereUniqueWithoutJoinChatRoomInput {
  where: WeChatUserWhereUniqueInput;
  data: WeChatUserUpdateWithoutJoinChatRoomDataInput;
}

export interface FileCreateWithoutContentInput {
  id?: Maybe<ID_Input>;
  fileName?: Maybe<FileIndexCreateOneInput>;
  size?: Maybe<Int>;
}

export interface WeChatUserUpdateWithoutJoinChatRoomDataInput {
  username?: Maybe<String>;
  alias?: Maybe<String>;
  conRemark?: Maybe<String>;
  nickname?: Maybe<String>;
  avatar?: Maybe<AvatarUpdateOneInput>;
  message?: Maybe<MessageUpdateManyWithoutTalkerInput>;
  haveChatRoom?: Maybe<ChatRoomUpdateManyWithoutOwnerInput>;
  contact?: Maybe<ContactUpdateOneWithoutWeChatUserInput>;
}

export interface ContentUpdateOneWithoutAppInput {
  create?: Maybe<ContentCreateWithoutAppInput>;
  update?: Maybe<ContentUpdateWithoutAppDataInput>;
  upsert?: Maybe<ContentUpsertWithoutAppInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ContentWhereUniqueInput>;
}

export interface ChatRoomUpdateManyWithoutOwnerInput {
  create?: Maybe<
    ChatRoomCreateWithoutOwnerInput[] | ChatRoomCreateWithoutOwnerInput
  >;
  delete?: Maybe<ChatRoomWhereUniqueInput[] | ChatRoomWhereUniqueInput>;
  connect?: Maybe<ChatRoomWhereUniqueInput[] | ChatRoomWhereUniqueInput>;
  set?: Maybe<ChatRoomWhereUniqueInput[] | ChatRoomWhereUniqueInput>;
  disconnect?: Maybe<ChatRoomWhereUniqueInput[] | ChatRoomWhereUniqueInput>;
  update?: Maybe<
    | ChatRoomUpdateWithWhereUniqueWithoutOwnerInput[]
    | ChatRoomUpdateWithWhereUniqueWithoutOwnerInput
  >;
  upsert?: Maybe<
    | ChatRoomUpsertWithWhereUniqueWithoutOwnerInput[]
    | ChatRoomUpsertWithWhereUniqueWithoutOwnerInput
  >;
  deleteMany?: Maybe<ChatRoomScalarWhereInput[] | ChatRoomScalarWhereInput>;
  updateMany?: Maybe<
    | ChatRoomUpdateManyWithWhereNestedInput[]
    | ChatRoomUpdateManyWithWhereNestedInput
  >;
}

export interface TextUpdateOneWithoutContentInput {
  create?: Maybe<TextCreateWithoutContentInput>;
  update?: Maybe<TextUpdateWithoutContentDataInput>;
  upsert?: Maybe<TextUpsertWithoutContentInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<TextWhereUniqueInput>;
}

export interface ChatRoomUpdateWithWhereUniqueWithoutOwnerInput {
  where: ChatRoomWhereUniqueInput;
  data: ChatRoomUpdateWithoutOwnerDataInput;
}

export interface TextUpsertWithoutContentInput {
  update: TextUpdateWithoutContentDataInput;
  create: TextCreateWithoutContentInput;
}

export interface ChatRoomUpdateWithoutOwnerDataInput {
  username?: Maybe<String>;
  nickname?: Maybe<String>;
  displayName?: Maybe<String>;
  memberList?: Maybe<WeChatUserUpdateManyWithoutJoinChatRoomInput>;
  modifyTime?: Maybe<DateTimeInput>;
  avatar?: Maybe<AvatarUpdateOneInput>;
  message?: Maybe<MessageUpdateManyWithoutChatRoomInput>;
}

export interface ImageUpdateWithoutContentDataInput {
  thumbnailImg?: Maybe<FileIndexUpdateOneInput>;
  bigImg?: Maybe<FileIndexUpdateOneInput>;
}

export interface MessageUpdateManyWithoutChatRoomInput {
  create?: Maybe<
    MessageCreateWithoutChatRoomInput[] | MessageCreateWithoutChatRoomInput
  >;
  delete?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  connect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  set?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  disconnect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  update?: Maybe<
    | MessageUpdateWithWhereUniqueWithoutChatRoomInput[]
    | MessageUpdateWithWhereUniqueWithoutChatRoomInput
  >;
  upsert?: Maybe<
    | MessageUpsertWithWhereUniqueWithoutChatRoomInput[]
    | MessageUpsertWithWhereUniqueWithoutChatRoomInput
  >;
  deleteMany?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
  updateMany?: Maybe<
    | MessageUpdateManyWithWhereNestedInput[]
    | MessageUpdateManyWithWhereNestedInput
  >;
}

export interface FileIndexUpdateDataInput {
  fileName?: Maybe<String>;
  mimetype?: Maybe<String>;
  size?: Maybe<Int>;
  urls?: Maybe<UrlUpdateManyWithoutFileIndexInput>;
}

export interface MessageUpdateWithWhereUniqueWithoutChatRoomInput {
  where: MessageWhereUniqueInput;
  data: MessageUpdateWithoutChatRoomDataInput;
}

export interface UrlUpdateWithWhereUniqueWithoutFileIndexInput {
  where: UrlWhereUniqueInput;
  data: UrlUpdateWithoutFileIndexDataInput;
}

export interface MessageUpdateWithoutChatRoomDataInput {
  msgSvrId?: Maybe<String>;
  isSend?: Maybe<Int>;
  type?: Maybe<Int>;
  talker?: Maybe<WeChatUserUpdateOneWithoutMessageInput>;
  createTime?: Maybe<DateTimeInput>;
  content?: Maybe<ContentUpdateOneInput>;
}

export interface UrlUpsertWithWhereUniqueWithoutFileIndexInput {
  where: UrlWhereUniqueInput;
  update: UrlUpdateWithoutFileIndexDataInput;
  create: UrlCreateWithoutFileIndexInput;
}

export interface WeChatUserUpdateOneWithoutMessageInput {
  create?: Maybe<WeChatUserCreateWithoutMessageInput>;
  update?: Maybe<WeChatUserUpdateWithoutMessageDataInput>;
  upsert?: Maybe<WeChatUserUpsertWithoutMessageInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<WeChatUserWhereUniqueInput>;
}

export interface UrlUpdateManyWithWhereNestedInput {
  where: UrlScalarWhereInput;
  data: UrlUpdateManyDataInput;
}

export interface WeChatUserUpdateWithoutMessageDataInput {
  username?: Maybe<String>;
  alias?: Maybe<String>;
  conRemark?: Maybe<String>;
  nickname?: Maybe<String>;
  avatar?: Maybe<AvatarUpdateOneInput>;
  haveChatRoom?: Maybe<ChatRoomUpdateManyWithoutOwnerInput>;
  joinChatRoom?: Maybe<ChatRoomUpdateManyWithoutMemberListInput>;
  contact?: Maybe<ContactUpdateOneWithoutWeChatUserInput>;
}

export interface FileIndexUpsertNestedInput {
  update: FileIndexUpdateDataInput;
  create: FileIndexCreateInput;
}

export interface ChatRoomUpdateManyWithoutMemberListInput {
  create?: Maybe<
    | ChatRoomCreateWithoutMemberListInput[]
    | ChatRoomCreateWithoutMemberListInput
  >;
  delete?: Maybe<ChatRoomWhereUniqueInput[] | ChatRoomWhereUniqueInput>;
  connect?: Maybe<ChatRoomWhereUniqueInput[] | ChatRoomWhereUniqueInput>;
  set?: Maybe<ChatRoomWhereUniqueInput[] | ChatRoomWhereUniqueInput>;
  disconnect?: Maybe<ChatRoomWhereUniqueInput[] | ChatRoomWhereUniqueInput>;
  update?: Maybe<
    | ChatRoomUpdateWithWhereUniqueWithoutMemberListInput[]
    | ChatRoomUpdateWithWhereUniqueWithoutMemberListInput
  >;
  upsert?: Maybe<
    | ChatRoomUpsertWithWhereUniqueWithoutMemberListInput[]
    | ChatRoomUpsertWithWhereUniqueWithoutMemberListInput
  >;
  deleteMany?: Maybe<ChatRoomScalarWhereInput[] | ChatRoomScalarWhereInput>;
  updateMany?: Maybe<
    | ChatRoomUpdateManyWithWhereNestedInput[]
    | ChatRoomUpdateManyWithWhereNestedInput
  >;
}

export interface VoiceUpdateOneWithoutContentInput {
  create?: Maybe<VoiceCreateWithoutContentInput>;
  update?: Maybe<VoiceUpdateWithoutContentDataInput>;
  upsert?: Maybe<VoiceUpsertWithoutContentInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<VoiceWhereUniqueInput>;
}

export interface ChatRoomUpdateWithWhereUniqueWithoutMemberListInput {
  where: ChatRoomWhereUniqueInput;
  data: ChatRoomUpdateWithoutMemberListDataInput;
}

export interface WeChatUserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<WeChatUserWhereInput>;
  AND?: Maybe<
    WeChatUserSubscriptionWhereInput[] | WeChatUserSubscriptionWhereInput
  >;
}

export interface ChatRoomUpdateWithoutMemberListDataInput {
  username?: Maybe<String>;
  nickname?: Maybe<String>;
  displayName?: Maybe<String>;
  owner?: Maybe<WeChatUserUpdateOneWithoutHaveChatRoomInput>;
  modifyTime?: Maybe<DateTimeInput>;
  avatar?: Maybe<AvatarUpdateOneInput>;
  message?: Maybe<MessageUpdateManyWithoutChatRoomInput>;
}

export interface AvatarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  thumbnailImg?: Maybe<UrlWhereInput>;
  bigImg?: Maybe<UrlWhereInput>;
  AND?: Maybe<AvatarWhereInput[] | AvatarWhereInput>;
}

export interface ChatRoomUpsertWithWhereUniqueWithoutMemberListInput {
  where: ChatRoomWhereUniqueInput;
  update: ChatRoomUpdateWithoutMemberListDataInput;
  create: ChatRoomCreateWithoutMemberListInput;
}

export interface UrlSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UrlWhereInput>;
  AND?: Maybe<UrlSubscriptionWhereInput[] | UrlSubscriptionWhereInput>;
}

export interface ChatRoomScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  nickname?: Maybe<String>;
  nickname_not?: Maybe<String>;
  nickname_in?: Maybe<String[] | String>;
  nickname_not_in?: Maybe<String[] | String>;
  nickname_lt?: Maybe<String>;
  nickname_lte?: Maybe<String>;
  nickname_gt?: Maybe<String>;
  nickname_gte?: Maybe<String>;
  nickname_contains?: Maybe<String>;
  nickname_not_contains?: Maybe<String>;
  nickname_starts_with?: Maybe<String>;
  nickname_not_starts_with?: Maybe<String>;
  nickname_ends_with?: Maybe<String>;
  nickname_not_ends_with?: Maybe<String>;
  displayName?: Maybe<String>;
  displayName_not?: Maybe<String>;
  displayName_in?: Maybe<String[] | String>;
  displayName_not_in?: Maybe<String[] | String>;
  displayName_lt?: Maybe<String>;
  displayName_lte?: Maybe<String>;
  displayName_gt?: Maybe<String>;
  displayName_gte?: Maybe<String>;
  displayName_contains?: Maybe<String>;
  displayName_not_contains?: Maybe<String>;
  displayName_starts_with?: Maybe<String>;
  displayName_not_starts_with?: Maybe<String>;
  displayName_ends_with?: Maybe<String>;
  displayName_not_ends_with?: Maybe<String>;
  modifyTime?: Maybe<DateTimeInput>;
  modifyTime_not?: Maybe<DateTimeInput>;
  modifyTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  modifyTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  modifyTime_lt?: Maybe<DateTimeInput>;
  modifyTime_lte?: Maybe<DateTimeInput>;
  modifyTime_gt?: Maybe<DateTimeInput>;
  modifyTime_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ChatRoomScalarWhereInput[] | ChatRoomScalarWhereInput>;
  OR?: Maybe<ChatRoomScalarWhereInput[] | ChatRoomScalarWhereInput>;
  NOT?: Maybe<ChatRoomScalarWhereInput[] | ChatRoomScalarWhereInput>;
}

export interface MessageWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  msgSvrId?: Maybe<String>;
  msgSvrId_not?: Maybe<String>;
  msgSvrId_in?: Maybe<String[] | String>;
  msgSvrId_not_in?: Maybe<String[] | String>;
  msgSvrId_lt?: Maybe<String>;
  msgSvrId_lte?: Maybe<String>;
  msgSvrId_gt?: Maybe<String>;
  msgSvrId_gte?: Maybe<String>;
  msgSvrId_contains?: Maybe<String>;
  msgSvrId_not_contains?: Maybe<String>;
  msgSvrId_starts_with?: Maybe<String>;
  msgSvrId_not_starts_with?: Maybe<String>;
  msgSvrId_ends_with?: Maybe<String>;
  msgSvrId_not_ends_with?: Maybe<String>;
  isSend?: Maybe<Int>;
  isSend_not?: Maybe<Int>;
  isSend_in?: Maybe<Int[] | Int>;
  isSend_not_in?: Maybe<Int[] | Int>;
  isSend_lt?: Maybe<Int>;
  isSend_lte?: Maybe<Int>;
  isSend_gt?: Maybe<Int>;
  isSend_gte?: Maybe<Int>;
  type?: Maybe<Int>;
  type_not?: Maybe<Int>;
  type_in?: Maybe<Int[] | Int>;
  type_not_in?: Maybe<Int[] | Int>;
  type_lt?: Maybe<Int>;
  type_lte?: Maybe<Int>;
  type_gt?: Maybe<Int>;
  type_gte?: Maybe<Int>;
  talker?: Maybe<WeChatUserWhereInput>;
  createTime?: Maybe<DateTimeInput>;
  createTime_not?: Maybe<DateTimeInput>;
  createTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createTime_lt?: Maybe<DateTimeInput>;
  createTime_lte?: Maybe<DateTimeInput>;
  createTime_gt?: Maybe<DateTimeInput>;
  createTime_gte?: Maybe<DateTimeInput>;
  chatRoom?: Maybe<ChatRoomWhereInput>;
  content?: Maybe<ContentWhereInput>;
  AND?: Maybe<MessageWhereInput[] | MessageWhereInput>;
}

export interface ChatRoomUpdateManyWithWhereNestedInput {
  where: ChatRoomScalarWhereInput;
  data: ChatRoomUpdateManyDataInput;
}

export interface ContactWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  weChatUser_some?: Maybe<WeChatUserWhereInput>;
  AND?: Maybe<ContactWhereInput[] | ContactWhereInput>;
}

export interface ChatRoomUpdateManyDataInput {
  username?: Maybe<String>;
  nickname?: Maybe<String>;
  displayName?: Maybe<String>;
  modifyTime?: Maybe<DateTimeInput>;
}

export interface FileSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FileWhereInput>;
  AND?: Maybe<FileSubscriptionWhereInput[] | FileSubscriptionWhereInput>;
}

export interface ContactUpdateOneWithoutWeChatUserInput {
  create?: Maybe<ContactCreateWithoutWeChatUserInput>;
  update?: Maybe<ContactUpdateWithoutWeChatUserDataInput>;
  upsert?: Maybe<ContactUpsertWithoutWeChatUserInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ContactWhereUniqueInput>;
}

export interface AvatarSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AvatarWhereInput>;
  AND?: Maybe<AvatarSubscriptionWhereInput[] | AvatarSubscriptionWhereInput>;
}

export interface ContactUpdateWithoutWeChatUserDataInput {
  type?: Maybe<String>;
}

export interface WeChatUserUpdateInput {
  username?: Maybe<String>;
  alias?: Maybe<String>;
  conRemark?: Maybe<String>;
  nickname?: Maybe<String>;
  avatar?: Maybe<AvatarUpdateOneInput>;
  message?: Maybe<MessageUpdateManyWithoutTalkerInput>;
  haveChatRoom?: Maybe<ChatRoomUpdateManyWithoutOwnerInput>;
  joinChatRoom?: Maybe<ChatRoomUpdateManyWithoutMemberListInput>;
  contact?: Maybe<ContactUpdateOneWithoutWeChatUserInput>;
}

export interface ContactUpsertWithoutWeChatUserInput {
  update: ContactUpdateWithoutWeChatUserDataInput;
  create: ContactCreateWithoutWeChatUserInput;
}

export interface ContentUpsertWithoutVoiceInput {
  update: ContentUpdateWithoutVoiceDataInput;
  create: ContentCreateWithoutVoiceInput;
}

export interface WeChatUserUpsertWithoutMessageInput {
  update: WeChatUserUpdateWithoutMessageDataInput;
  create: WeChatUserCreateWithoutMessageInput;
}

export interface FileIndexWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  fileName?: Maybe<String>;
  fileName_not?: Maybe<String>;
  fileName_in?: Maybe<String[] | String>;
  fileName_not_in?: Maybe<String[] | String>;
  fileName_lt?: Maybe<String>;
  fileName_lte?: Maybe<String>;
  fileName_gt?: Maybe<String>;
  fileName_gte?: Maybe<String>;
  fileName_contains?: Maybe<String>;
  fileName_not_contains?: Maybe<String>;
  fileName_starts_with?: Maybe<String>;
  fileName_not_starts_with?: Maybe<String>;
  fileName_ends_with?: Maybe<String>;
  fileName_not_ends_with?: Maybe<String>;
  mimetype?: Maybe<String>;
  mimetype_not?: Maybe<String>;
  mimetype_in?: Maybe<String[] | String>;
  mimetype_not_in?: Maybe<String[] | String>;
  mimetype_lt?: Maybe<String>;
  mimetype_lte?: Maybe<String>;
  mimetype_gt?: Maybe<String>;
  mimetype_gte?: Maybe<String>;
  mimetype_contains?: Maybe<String>;
  mimetype_not_contains?: Maybe<String>;
  mimetype_starts_with?: Maybe<String>;
  mimetype_not_starts_with?: Maybe<String>;
  mimetype_ends_with?: Maybe<String>;
  mimetype_not_ends_with?: Maybe<String>;
  size?: Maybe<Int>;
  size_not?: Maybe<Int>;
  size_in?: Maybe<Int[] | Int>;
  size_not_in?: Maybe<Int[] | Int>;
  size_lt?: Maybe<Int>;
  size_lte?: Maybe<Int>;
  size_gt?: Maybe<Int>;
  size_gte?: Maybe<Int>;
  urls_some?: Maybe<UrlWhereInput>;
  AND?: Maybe<FileIndexWhereInput[] | FileIndexWhereInput>;
}

export interface ContentUpdateOneInput {
  create?: Maybe<ContentCreateInput>;
  update?: Maybe<ContentUpdateDataInput>;
  upsert?: Maybe<ContentUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ContentWhereUniqueInput>;
}

export type FileGroupWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface ContentUpdateDataInput {
  text?: Maybe<TextUpdateOneWithoutContentInput>;
  image?: Maybe<ImageUpdateOneWithoutContentInput>;
  voice?: Maybe<VoiceUpdateOneWithoutContentInput>;
  video?: Maybe<VideoUpdateOneWithoutContentInput>;
  file?: Maybe<FileUpdateOneWithoutContentInput>;
  app?: Maybe<AppUpdateOneWithoutContentInput>;
}

export interface VideoUpdateManyMutationInput {
  videolength?: Maybe<Int>;
}

export interface AppUpdateOneWithoutContentInput {
  create?: Maybe<AppCreateWithoutContentInput>;
  update?: Maybe<AppUpdateWithoutContentDataInput>;
  upsert?: Maybe<AppUpsertWithoutContentInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<AppWhereUniqueInput>;
}

export type FileIndexWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  fileName?: Maybe<String>;
}>;

export interface AppUpdateWithoutContentDataInput {
  xml?: Maybe<Json>;
}

export type ImageWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AppUpsertWithoutContentInput {
  update: AppUpdateWithoutContentDataInput;
  create: AppCreateWithoutContentInput;
}

export interface WeChatUpsertWithWhereUniqueNestedInput {
  where: WeChatWhereUniqueInput;
  update: WeChatUpdateDataInput;
  create: WeChatCreateInput;
}

export interface ContentUpsertNestedInput {
  update: ContentUpdateDataInput;
  create: ContentCreateInput;
}

export interface MessageUpdateWithWhereUniqueNestedInput {
  where: MessageWhereUniqueInput;
  data: MessageUpdateDataInput;
}

export interface MessageUpsertWithWhereUniqueWithoutChatRoomInput {
  where: MessageWhereUniqueInput;
  update: MessageUpdateWithoutChatRoomDataInput;
  create: MessageCreateWithoutChatRoomInput;
}

export interface ChatRoomUpdateDataInput {
  username?: Maybe<String>;
  nickname?: Maybe<String>;
  displayName?: Maybe<String>;
  owner?: Maybe<WeChatUserUpdateOneWithoutHaveChatRoomInput>;
  memberList?: Maybe<WeChatUserUpdateManyWithoutJoinChatRoomInput>;
  modifyTime?: Maybe<DateTimeInput>;
  avatar?: Maybe<AvatarUpdateOneInput>;
  message?: Maybe<MessageUpdateManyWithoutChatRoomInput>;
}

export interface MessageScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  msgSvrId?: Maybe<String>;
  msgSvrId_not?: Maybe<String>;
  msgSvrId_in?: Maybe<String[] | String>;
  msgSvrId_not_in?: Maybe<String[] | String>;
  msgSvrId_lt?: Maybe<String>;
  msgSvrId_lte?: Maybe<String>;
  msgSvrId_gt?: Maybe<String>;
  msgSvrId_gte?: Maybe<String>;
  msgSvrId_contains?: Maybe<String>;
  msgSvrId_not_contains?: Maybe<String>;
  msgSvrId_starts_with?: Maybe<String>;
  msgSvrId_not_starts_with?: Maybe<String>;
  msgSvrId_ends_with?: Maybe<String>;
  msgSvrId_not_ends_with?: Maybe<String>;
  isSend?: Maybe<Int>;
  isSend_not?: Maybe<Int>;
  isSend_in?: Maybe<Int[] | Int>;
  isSend_not_in?: Maybe<Int[] | Int>;
  isSend_lt?: Maybe<Int>;
  isSend_lte?: Maybe<Int>;
  isSend_gt?: Maybe<Int>;
  isSend_gte?: Maybe<Int>;
  type?: Maybe<Int>;
  type_not?: Maybe<Int>;
  type_in?: Maybe<Int[] | Int>;
  type_not_in?: Maybe<Int[] | Int>;
  type_lt?: Maybe<Int>;
  type_lte?: Maybe<Int>;
  type_gt?: Maybe<Int>;
  type_gte?: Maybe<Int>;
  createTime?: Maybe<DateTimeInput>;
  createTime_not?: Maybe<DateTimeInput>;
  createTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createTime_lt?: Maybe<DateTimeInput>;
  createTime_lte?: Maybe<DateTimeInput>;
  createTime_gt?: Maybe<DateTimeInput>;
  createTime_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
  OR?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
  NOT?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
}

export interface WeChatUserUpsertWithWhereUniqueNestedInput {
  where: WeChatUserWhereUniqueInput;
  update: WeChatUserUpdateDataInput;
  create: WeChatUserCreateInput;
}

export interface MessageUpdateManyWithWhereNestedInput {
  where: MessageScalarWhereInput;
  data: MessageUpdateManyDataInput;
}

export interface WeChatWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  weChatOwner?: Maybe<WeChatUserWhereInput>;
  weChatUsers_some?: Maybe<WeChatUserWhereInput>;
  chatRooms_some?: Maybe<ChatRoomWhereInput>;
  messages_some?: Maybe<MessageWhereInput>;
  AND?: Maybe<WeChatWhereInput[] | WeChatWhereInput>;
}

export interface MessageUpdateManyDataInput {
  msgSvrId?: Maybe<String>;
  isSend?: Maybe<Int>;
  type?: Maybe<Int>;
  createTime?: Maybe<DateTimeInput>;
}

export interface WeChatUserUpdateOneRequiredInput {
  create?: Maybe<WeChatUserCreateInput>;
  update?: Maybe<WeChatUserUpdateDataInput>;
  upsert?: Maybe<WeChatUserUpsertNestedInput>;
  connect?: Maybe<WeChatUserWhereUniqueInput>;
}

export interface ChatRoomUpsertWithWhereUniqueWithoutOwnerInput {
  where: ChatRoomWhereUniqueInput;
  update: ChatRoomUpdateWithoutOwnerDataInput;
  create: ChatRoomCreateWithoutOwnerInput;
}

export type VideoWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface WeChatUserUpsertWithWhereUniqueWithoutJoinChatRoomInput {
  where: WeChatUserWhereUniqueInput;
  update: WeChatUserUpdateWithoutJoinChatRoomDataInput;
  create: WeChatUserCreateWithoutJoinChatRoomInput;
}

export interface WeChatUserCreateManyInput {
  create?: Maybe<WeChatUserCreateInput[] | WeChatUserCreateInput>;
  connect?: Maybe<WeChatUserWhereUniqueInput[] | WeChatUserWhereUniqueInput>;
}

export interface WeChatUserScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  alias?: Maybe<String>;
  alias_not?: Maybe<String>;
  alias_in?: Maybe<String[] | String>;
  alias_not_in?: Maybe<String[] | String>;
  alias_lt?: Maybe<String>;
  alias_lte?: Maybe<String>;
  alias_gt?: Maybe<String>;
  alias_gte?: Maybe<String>;
  alias_contains?: Maybe<String>;
  alias_not_contains?: Maybe<String>;
  alias_starts_with?: Maybe<String>;
  alias_not_starts_with?: Maybe<String>;
  alias_ends_with?: Maybe<String>;
  alias_not_ends_with?: Maybe<String>;
  conRemark?: Maybe<String>;
  conRemark_not?: Maybe<String>;
  conRemark_in?: Maybe<String[] | String>;
  conRemark_not_in?: Maybe<String[] | String>;
  conRemark_lt?: Maybe<String>;
  conRemark_lte?: Maybe<String>;
  conRemark_gt?: Maybe<String>;
  conRemark_gte?: Maybe<String>;
  conRemark_contains?: Maybe<String>;
  conRemark_not_contains?: Maybe<String>;
  conRemark_starts_with?: Maybe<String>;
  conRemark_not_starts_with?: Maybe<String>;
  conRemark_ends_with?: Maybe<String>;
  conRemark_not_ends_with?: Maybe<String>;
  nickname?: Maybe<String>;
  nickname_not?: Maybe<String>;
  nickname_in?: Maybe<String[] | String>;
  nickname_not_in?: Maybe<String[] | String>;
  nickname_lt?: Maybe<String>;
  nickname_lte?: Maybe<String>;
  nickname_gt?: Maybe<String>;
  nickname_gte?: Maybe<String>;
  nickname_contains?: Maybe<String>;
  nickname_not_contains?: Maybe<String>;
  nickname_starts_with?: Maybe<String>;
  nickname_not_starts_with?: Maybe<String>;
  nickname_ends_with?: Maybe<String>;
  nickname_not_ends_with?: Maybe<String>;
  AND?: Maybe<WeChatUserScalarWhereInput[] | WeChatUserScalarWhereInput>;
  OR?: Maybe<WeChatUserScalarWhereInput[] | WeChatUserScalarWhereInput>;
  NOT?: Maybe<WeChatUserScalarWhereInput[] | WeChatUserScalarWhereInput>;
}

export interface WeChatCreateInput {
  id?: Maybe<ID_Input>;
  weChatOwner: WeChatUserCreateOneInput;
  weChatUsers?: Maybe<WeChatUserCreateManyInput>;
  chatRooms?: Maybe<ChatRoomCreateManyInput>;
  messages?: Maybe<MessageCreateManyInput>;
}

export interface WeChatUserUpdateManyWithWhereNestedInput {
  where: WeChatUserScalarWhereInput;
  data: WeChatUserUpdateManyDataInput;
}

export interface UrlUpdateManyMutationInput {
  url?: Maybe<String>;
}

export interface WeChatUserUpdateManyDataInput {
  username?: Maybe<String>;
  alias?: Maybe<String>;
  conRemark?: Maybe<String>;
  nickname?: Maybe<String>;
}

export interface ContentUpsertWithoutTextInput {
  update: ContentUpdateWithoutTextDataInput;
  create: ContentCreateWithoutTextInput;
}

export interface ChatRoomUpsertWithoutMessageInput {
  update: ChatRoomUpdateWithoutMessageDataInput;
  create: ChatRoomCreateWithoutMessageInput;
}

export interface ContentCreateOneWithoutAppInput {
  create?: Maybe<ContentCreateWithoutAppInput>;
  connect?: Maybe<ContentWhereUniqueInput>;
}

export interface MessageUpsertWithWhereUniqueWithoutTalkerInput {
  where: MessageWhereUniqueInput;
  update: MessageUpdateWithoutTalkerDataInput;
  create: MessageCreateWithoutTalkerInput;
}

export interface ImageCreateOneWithoutContentInput {
  create?: Maybe<ImageCreateWithoutContentInput>;
  connect?: Maybe<ImageWhereUniqueInput>;
}

export interface WeChatUserUpsertWithoutHaveChatRoomInput {
  update: WeChatUserUpdateWithoutHaveChatRoomDataInput;
  create: WeChatUserCreateWithoutHaveChatRoomInput;
}

export interface UrlCreateManyWithoutFileIndexInput {
  create?: Maybe<
    UrlCreateWithoutFileIndexInput[] | UrlCreateWithoutFileIndexInput
  >;
  connect?: Maybe<UrlWhereUniqueInput[] | UrlWhereUniqueInput>;
}

export interface ChatRoomUpdateManyMutationInput {
  username?: Maybe<String>;
  nickname?: Maybe<String>;
  displayName?: Maybe<String>;
  modifyTime?: Maybe<DateTimeInput>;
}

export interface VideoCreateOneWithoutContentInput {
  create?: Maybe<VideoCreateWithoutContentInput>;
  connect?: Maybe<VideoWhereUniqueInput>;
}

export interface ContactCreateInput {
  id?: Maybe<ID_Input>;
  type: String;
  weChatUser?: Maybe<WeChatUserCreateManyWithoutContactInput>;
}

export interface AppUpdateInput {
  xml?: Maybe<Json>;
  content?: Maybe<ContentUpdateOneWithoutAppInput>;
}

export interface WeChatUserCreateManyWithoutContactInput {
  create?: Maybe<
    WeChatUserCreateWithoutContactInput[] | WeChatUserCreateWithoutContactInput
  >;
  connect?: Maybe<WeChatUserWhereUniqueInput[] | WeChatUserWhereUniqueInput>;
}

export interface TextUpdateWithoutContentDataInput {
  textMsg?: Maybe<String>;
}

export interface WeChatUserCreateWithoutContactInput {
  id?: Maybe<ID_Input>;
  username: String;
  alias?: Maybe<String>;
  conRemark?: Maybe<String>;
  nickname?: Maybe<String>;
  avatar?: Maybe<AvatarCreateOneInput>;
  message?: Maybe<MessageCreateManyWithoutTalkerInput>;
  haveChatRoom?: Maybe<ChatRoomCreateManyWithoutOwnerInput>;
  joinChatRoom?: Maybe<ChatRoomCreateManyWithoutMemberListInput>;
}

export interface FileIndexUpdateOneInput {
  create?: Maybe<FileIndexCreateInput>;
  update?: Maybe<FileIndexUpdateDataInput>;
  upsert?: Maybe<FileIndexUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<FileIndexWhereUniqueInput>;
}

export interface ContactUpdateInput {
  type?: Maybe<String>;
  weChatUser?: Maybe<WeChatUserUpdateManyWithoutContactInput>;
}

export interface UrlUpdateWithoutFileIndexDataInput {
  url?: Maybe<String>;
}

export interface WeChatUserUpdateManyWithoutContactInput {
  create?: Maybe<
    WeChatUserCreateWithoutContactInput[] | WeChatUserCreateWithoutContactInput
  >;
  delete?: Maybe<WeChatUserWhereUniqueInput[] | WeChatUserWhereUniqueInput>;
  connect?: Maybe<WeChatUserWhereUniqueInput[] | WeChatUserWhereUniqueInput>;
  set?: Maybe<WeChatUserWhereUniqueInput[] | WeChatUserWhereUniqueInput>;
  disconnect?: Maybe<WeChatUserWhereUniqueInput[] | WeChatUserWhereUniqueInput>;
  update?: Maybe<
    | WeChatUserUpdateWithWhereUniqueWithoutContactInput[]
    | WeChatUserUpdateWithWhereUniqueWithoutContactInput
  >;
  upsert?: Maybe<
    | WeChatUserUpsertWithWhereUniqueWithoutContactInput[]
    | WeChatUserUpsertWithWhereUniqueWithoutContactInput
  >;
  deleteMany?: Maybe<WeChatUserScalarWhereInput[] | WeChatUserScalarWhereInput>;
  updateMany?: Maybe<
    | WeChatUserUpdateManyWithWhereNestedInput[]
    | WeChatUserUpdateManyWithWhereNestedInput
  >;
}

export interface UrlUpdateManyDataInput {
  url?: Maybe<String>;
}

export interface WeChatUserUpdateWithWhereUniqueWithoutContactInput {
  where: WeChatUserWhereUniqueInput;
  data: WeChatUserUpdateWithoutContactDataInput;
}

export interface VoiceUpdateWithoutContentDataInput {
  fileName?: Maybe<FileIndexUpdateOneInput>;
  voiceLength?: Maybe<Int>;
}

export interface WeChatUserUpdateWithoutContactDataInput {
  username?: Maybe<String>;
  alias?: Maybe<String>;
  conRemark?: Maybe<String>;
  nickname?: Maybe<String>;
  avatar?: Maybe<AvatarUpdateOneInput>;
  message?: Maybe<MessageUpdateManyWithoutTalkerInput>;
  haveChatRoom?: Maybe<ChatRoomUpdateManyWithoutOwnerInput>;
  joinChatRoom?: Maybe<ChatRoomUpdateManyWithoutMemberListInput>;
}

export interface VideoSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<VideoWhereInput>;
  AND?: Maybe<VideoSubscriptionWhereInput[] | VideoSubscriptionWhereInput>;
}

export interface WeChatUserUpsertWithWhereUniqueWithoutContactInput {
  where: WeChatUserWhereUniqueInput;
  update: WeChatUserUpdateWithoutContactDataInput;
  create: WeChatUserCreateWithoutContactInput;
}

export interface ChatRoomWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  nickname?: Maybe<String>;
  nickname_not?: Maybe<String>;
  nickname_in?: Maybe<String[] | String>;
  nickname_not_in?: Maybe<String[] | String>;
  nickname_lt?: Maybe<String>;
  nickname_lte?: Maybe<String>;
  nickname_gt?: Maybe<String>;
  nickname_gte?: Maybe<String>;
  nickname_contains?: Maybe<String>;
  nickname_not_contains?: Maybe<String>;
  nickname_starts_with?: Maybe<String>;
  nickname_not_starts_with?: Maybe<String>;
  nickname_ends_with?: Maybe<String>;
  nickname_not_ends_with?: Maybe<String>;
  displayName?: Maybe<String>;
  displayName_not?: Maybe<String>;
  displayName_in?: Maybe<String[] | String>;
  displayName_not_in?: Maybe<String[] | String>;
  displayName_lt?: Maybe<String>;
  displayName_lte?: Maybe<String>;
  displayName_gt?: Maybe<String>;
  displayName_gte?: Maybe<String>;
  displayName_contains?: Maybe<String>;
  displayName_not_contains?: Maybe<String>;
  displayName_starts_with?: Maybe<String>;
  displayName_not_starts_with?: Maybe<String>;
  displayName_ends_with?: Maybe<String>;
  displayName_not_ends_with?: Maybe<String>;
  owner?: Maybe<WeChatUserWhereInput>;
  memberList_some?: Maybe<WeChatUserWhereInput>;
  modifyTime?: Maybe<DateTimeInput>;
  modifyTime_not?: Maybe<DateTimeInput>;
  modifyTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  modifyTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  modifyTime_lt?: Maybe<DateTimeInput>;
  modifyTime_lte?: Maybe<DateTimeInput>;
  modifyTime_gt?: Maybe<DateTimeInput>;
  modifyTime_gte?: Maybe<DateTimeInput>;
  avatar?: Maybe<AvatarWhereInput>;
  message_some?: Maybe<MessageWhereInput>;
  AND?: Maybe<ChatRoomWhereInput[] | ChatRoomWhereInput>;
}

export interface ContactUpdateManyMutationInput {
  type?: Maybe<String>;
}

export interface ContactSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ContactWhereInput>;
  AND?: Maybe<ContactSubscriptionWhereInput[] | ContactSubscriptionWhereInput>;
}

export interface ContentUpdateInput {
  text?: Maybe<TextUpdateOneWithoutContentInput>;
  image?: Maybe<ImageUpdateOneWithoutContentInput>;
  voice?: Maybe<VoiceUpdateOneWithoutContentInput>;
  video?: Maybe<VideoUpdateOneWithoutContentInput>;
  file?: Maybe<FileUpdateOneWithoutContentInput>;
  app?: Maybe<AppUpdateOneWithoutContentInput>;
}

export type ContentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface FileCreateInput {
  id?: Maybe<ID_Input>;
  fileName?: Maybe<FileIndexCreateOneInput>;
  size?: Maybe<Int>;
  content?: Maybe<ContentCreateOneWithoutFileInput>;
}

export interface ContentCreateWithoutVoiceInput {
  id?: Maybe<ID_Input>;
  text?: Maybe<TextCreateOneWithoutContentInput>;
  image?: Maybe<ImageCreateOneWithoutContentInput>;
  video?: Maybe<VideoCreateOneWithoutContentInput>;
  file?: Maybe<FileCreateOneWithoutContentInput>;
  app?: Maybe<AppCreateOneWithoutContentInput>;
}

export interface ContentCreateOneWithoutFileInput {
  create?: Maybe<ContentCreateWithoutFileInput>;
  connect?: Maybe<ContentWhereUniqueInput>;
}

export interface ContentUpdateWithoutVideoDataInput {
  text?: Maybe<TextUpdateOneWithoutContentInput>;
  image?: Maybe<ImageUpdateOneWithoutContentInput>;
  voice?: Maybe<VoiceUpdateOneWithoutContentInput>;
  file?: Maybe<FileUpdateOneWithoutContentInput>;
  app?: Maybe<AppUpdateOneWithoutContentInput>;
}

export interface ContentCreateWithoutFileInput {
  id?: Maybe<ID_Input>;
  text?: Maybe<TextCreateOneWithoutContentInput>;
  image?: Maybe<ImageCreateOneWithoutContentInput>;
  voice?: Maybe<VoiceCreateOneWithoutContentInput>;
  video?: Maybe<VideoCreateOneWithoutContentInput>;
  app?: Maybe<AppCreateOneWithoutContentInput>;
}

export interface UserUpdateManyMutationInput {
  email?: Maybe<String>;
  name?: Maybe<String>;
  password?: Maybe<String>;
}

export interface FileUpdateInput {
  fileName?: Maybe<FileIndexUpdateOneInput>;
  size?: Maybe<Int>;
  content?: Maybe<ContentUpdateOneWithoutFileInput>;
}

export interface MessageUpdateManyInput {
  create?: Maybe<MessageCreateInput[] | MessageCreateInput>;
  update?: Maybe<
    | MessageUpdateWithWhereUniqueNestedInput[]
    | MessageUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | MessageUpsertWithWhereUniqueNestedInput[]
    | MessageUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  connect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  set?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  disconnect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  deleteMany?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
  updateMany?: Maybe<
    | MessageUpdateManyWithWhereNestedInput[]
    | MessageUpdateManyWithWhereNestedInput
  >;
}

export interface ContentUpdateOneWithoutFileInput {
  create?: Maybe<ContentCreateWithoutFileInput>;
  update?: Maybe<ContentUpdateWithoutFileDataInput>;
  upsert?: Maybe<ContentUpsertWithoutFileInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ContentWhereUniqueInput>;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface ContentUpdateWithoutFileDataInput {
  text?: Maybe<TextUpdateOneWithoutContentInput>;
  image?: Maybe<ImageUpdateOneWithoutContentInput>;
  voice?: Maybe<VoiceUpdateOneWithoutContentInput>;
  video?: Maybe<VideoUpdateOneWithoutContentInput>;
  app?: Maybe<AppUpdateOneWithoutContentInput>;
}

export interface WeChatUpdateWithWhereUniqueNestedInput {
  where: WeChatWhereUniqueInput;
  data: WeChatUpdateDataInput;
}

export interface ContentUpsertWithoutFileInput {
  update: ContentUpdateWithoutFileDataInput;
  create: ContentCreateWithoutFileInput;
}

export interface WeChatUserCreateInput {
  id?: Maybe<ID_Input>;
  username: String;
  alias?: Maybe<String>;
  conRemark?: Maybe<String>;
  nickname?: Maybe<String>;
  avatar?: Maybe<AvatarCreateOneInput>;
  message?: Maybe<MessageCreateManyWithoutTalkerInput>;
  haveChatRoom?: Maybe<ChatRoomCreateManyWithoutOwnerInput>;
  joinChatRoom?: Maybe<ChatRoomCreateManyWithoutMemberListInput>;
  contact?: Maybe<ContactCreateOneWithoutWeChatUserInput>;
}

export interface FileUpdateManyMutationInput {
  size?: Maybe<Int>;
}

export type WeChatUserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  username?: Maybe<String>;
}>;

export interface FileGroupCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  fileIndexes?: Maybe<FileIndexCreateManyInput>;
}

export interface TextCreateOneWithoutContentInput {
  create?: Maybe<TextCreateWithoutContentInput>;
  connect?: Maybe<TextWhereUniqueInput>;
}

export interface FileIndexCreateManyInput {
  create?: Maybe<FileIndexCreateInput[] | FileIndexCreateInput>;
  connect?: Maybe<FileIndexWhereUniqueInput[] | FileIndexWhereUniqueInput>;
}

export interface VoiceCreateOneWithoutContentInput {
  create?: Maybe<VoiceCreateWithoutContentInput>;
  connect?: Maybe<VoiceWhereUniqueInput>;
}

export interface FileGroupUpdateInput {
  name?: Maybe<String>;
  fileIndexes?: Maybe<FileIndexUpdateManyInput>;
}

export interface ContentUpdateWithoutAppDataInput {
  text?: Maybe<TextUpdateOneWithoutContentInput>;
  image?: Maybe<ImageUpdateOneWithoutContentInput>;
  voice?: Maybe<VoiceUpdateOneWithoutContentInput>;
  video?: Maybe<VideoUpdateOneWithoutContentInput>;
  file?: Maybe<FileUpdateOneWithoutContentInput>;
}

export interface FileIndexUpdateManyInput {
  create?: Maybe<FileIndexCreateInput[] | FileIndexCreateInput>;
  update?: Maybe<
    | FileIndexUpdateWithWhereUniqueNestedInput[]
    | FileIndexUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | FileIndexUpsertWithWhereUniqueNestedInput[]
    | FileIndexUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<FileIndexWhereUniqueInput[] | FileIndexWhereUniqueInput>;
  connect?: Maybe<FileIndexWhereUniqueInput[] | FileIndexWhereUniqueInput>;
  set?: Maybe<FileIndexWhereUniqueInput[] | FileIndexWhereUniqueInput>;
  disconnect?: Maybe<FileIndexWhereUniqueInput[] | FileIndexWhereUniqueInput>;
  deleteMany?: Maybe<FileIndexScalarWhereInput[] | FileIndexScalarWhereInput>;
  updateMany?: Maybe<
    | FileIndexUpdateManyWithWhereNestedInput[]
    | FileIndexUpdateManyWithWhereNestedInput
  >;
}

export interface UrlUpdateManyWithoutFileIndexInput {
  create?: Maybe<
    UrlCreateWithoutFileIndexInput[] | UrlCreateWithoutFileIndexInput
  >;
  delete?: Maybe<UrlWhereUniqueInput[] | UrlWhereUniqueInput>;
  connect?: Maybe<UrlWhereUniqueInput[] | UrlWhereUniqueInput>;
  set?: Maybe<UrlWhereUniqueInput[] | UrlWhereUniqueInput>;
  disconnect?: Maybe<UrlWhereUniqueInput[] | UrlWhereUniqueInput>;
  update?: Maybe<
    | UrlUpdateWithWhereUniqueWithoutFileIndexInput[]
    | UrlUpdateWithWhereUniqueWithoutFileIndexInput
  >;
  upsert?: Maybe<
    | UrlUpsertWithWhereUniqueWithoutFileIndexInput[]
    | UrlUpsertWithWhereUniqueWithoutFileIndexInput
  >;
  deleteMany?: Maybe<UrlScalarWhereInput[] | UrlScalarWhereInput>;
  updateMany?: Maybe<
    UrlUpdateManyWithWhereNestedInput[] | UrlUpdateManyWithWhereNestedInput
  >;
}

export interface FileIndexUpdateWithWhereUniqueNestedInput {
  where: FileIndexWhereUniqueInput;
  data: FileIndexUpdateDataInput;
}

export interface ImageUpsertWithoutContentInput {
  update: ImageUpdateWithoutContentDataInput;
  create: ImageCreateWithoutContentInput;
}

export interface FileIndexUpsertWithWhereUniqueNestedInput {
  where: FileIndexWhereUniqueInput;
  update: FileIndexUpdateDataInput;
  create: FileIndexCreateInput;
}

export interface TextSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TextWhereInput>;
  AND?: Maybe<TextSubscriptionWhereInput[] | TextSubscriptionWhereInput>;
}

export interface FileIndexScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  fileName?: Maybe<String>;
  fileName_not?: Maybe<String>;
  fileName_in?: Maybe<String[] | String>;
  fileName_not_in?: Maybe<String[] | String>;
  fileName_lt?: Maybe<String>;
  fileName_lte?: Maybe<String>;
  fileName_gt?: Maybe<String>;
  fileName_gte?: Maybe<String>;
  fileName_contains?: Maybe<String>;
  fileName_not_contains?: Maybe<String>;
  fileName_starts_with?: Maybe<String>;
  fileName_not_starts_with?: Maybe<String>;
  fileName_ends_with?: Maybe<String>;
  fileName_not_ends_with?: Maybe<String>;
  mimetype?: Maybe<String>;
  mimetype_not?: Maybe<String>;
  mimetype_in?: Maybe<String[] | String>;
  mimetype_not_in?: Maybe<String[] | String>;
  mimetype_lt?: Maybe<String>;
  mimetype_lte?: Maybe<String>;
  mimetype_gt?: Maybe<String>;
  mimetype_gte?: Maybe<String>;
  mimetype_contains?: Maybe<String>;
  mimetype_not_contains?: Maybe<String>;
  mimetype_starts_with?: Maybe<String>;
  mimetype_not_starts_with?: Maybe<String>;
  mimetype_ends_with?: Maybe<String>;
  mimetype_not_ends_with?: Maybe<String>;
  size?: Maybe<Int>;
  size_not?: Maybe<Int>;
  size_in?: Maybe<Int[] | Int>;
  size_not_in?: Maybe<Int[] | Int>;
  size_lt?: Maybe<Int>;
  size_lte?: Maybe<Int>;
  size_gt?: Maybe<Int>;
  size_gte?: Maybe<Int>;
  AND?: Maybe<FileIndexScalarWhereInput[] | FileIndexScalarWhereInput>;
  OR?: Maybe<FileIndexScalarWhereInput[] | FileIndexScalarWhereInput>;
  NOT?: Maybe<FileIndexScalarWhereInput[] | FileIndexScalarWhereInput>;
}

export interface AppSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AppWhereInput>;
  AND?: Maybe<AppSubscriptionWhereInput[] | AppSubscriptionWhereInput>;
}

export interface FileIndexUpdateManyWithWhereNestedInput {
  where: FileIndexScalarWhereInput;
  data: FileIndexUpdateManyDataInput;
}

export interface UrlWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  fileIndex?: Maybe<FileIndexWhereInput>;
  AND?: Maybe<UrlWhereInput[] | UrlWhereInput>;
}

export interface FileIndexUpdateManyDataInput {
  fileName?: Maybe<String>;
  mimetype?: Maybe<String>;
  size?: Maybe<Int>;
}

export interface MessageUpsertWithWhereUniqueNestedInput {
  where: MessageWhereUniqueInput;
  update: MessageUpdateDataInput;
  create: MessageCreateInput;
}

export interface FileGroupUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface WeChatUserUpdateDataInput {
  username?: Maybe<String>;
  alias?: Maybe<String>;
  conRemark?: Maybe<String>;
  nickname?: Maybe<String>;
  avatar?: Maybe<AvatarUpdateOneInput>;
  message?: Maybe<MessageUpdateManyWithoutTalkerInput>;
  haveChatRoom?: Maybe<ChatRoomUpdateManyWithoutOwnerInput>;
  joinChatRoom?: Maybe<ChatRoomUpdateManyWithoutMemberListInput>;
  contact?: Maybe<ContactUpdateOneWithoutWeChatUserInput>;
}

export interface FileIndexUpdateInput {
  fileName?: Maybe<String>;
  mimetype?: Maybe<String>;
  size?: Maybe<Int>;
  urls?: Maybe<UrlUpdateManyWithoutFileIndexInput>;
}

export type WeChatWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface FileIndexUpdateManyMutationInput {
  fileName?: Maybe<String>;
  mimetype?: Maybe<String>;
  size?: Maybe<Int>;
}

export interface FileIndexCreateOneInput {
  create?: Maybe<FileIndexCreateInput>;
  connect?: Maybe<FileIndexWhereUniqueInput>;
}

export interface ImageCreateInput {
  id?: Maybe<ID_Input>;
  thumbnailImg?: Maybe<FileIndexCreateOneInput>;
  bigImg?: Maybe<FileIndexCreateOneInput>;
  content?: Maybe<ContentCreateOneWithoutImageInput>;
}

export interface ImageUpdateOneWithoutContentInput {
  create?: Maybe<ImageCreateWithoutContentInput>;
  update?: Maybe<ImageUpdateWithoutContentDataInput>;
  upsert?: Maybe<ImageUpsertWithoutContentInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ImageWhereUniqueInput>;
}

export interface ContentCreateOneWithoutImageInput {
  create?: Maybe<ContentCreateWithoutImageInput>;
  connect?: Maybe<ContentWhereUniqueInput>;
}

export type AvatarWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ContentCreateWithoutImageInput {
  id?: Maybe<ID_Input>;
  text?: Maybe<TextCreateOneWithoutContentInput>;
  voice?: Maybe<VoiceCreateOneWithoutContentInput>;
  video?: Maybe<VideoCreateOneWithoutContentInput>;
  file?: Maybe<FileCreateOneWithoutContentInput>;
  app?: Maybe<AppCreateOneWithoutContentInput>;
}

export interface ContentUpdateOneWithoutVoiceInput {
  create?: Maybe<ContentCreateWithoutVoiceInput>;
  update?: Maybe<ContentUpdateWithoutVoiceDataInput>;
  upsert?: Maybe<ContentUpsertWithoutVoiceInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ContentWhereUniqueInput>;
}

export interface ImageUpdateInput {
  thumbnailImg?: Maybe<FileIndexUpdateOneInput>;
  bigImg?: Maybe<FileIndexUpdateOneInput>;
  content?: Maybe<ContentUpdateOneWithoutImageInput>;
}

export type UrlWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ContentUpdateOneWithoutImageInput {
  create?: Maybe<ContentCreateWithoutImageInput>;
  update?: Maybe<ContentUpdateWithoutImageDataInput>;
  upsert?: Maybe<ContentUpsertWithoutImageInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ContentWhereUniqueInput>;
}

export interface UrlScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  AND?: Maybe<UrlScalarWhereInput[] | UrlScalarWhereInput>;
  OR?: Maybe<UrlScalarWhereInput[] | UrlScalarWhereInput>;
  NOT?: Maybe<UrlScalarWhereInput[] | UrlScalarWhereInput>;
}

export interface MessageUpdateInput {
  msgSvrId?: Maybe<String>;
  isSend?: Maybe<Int>;
  type?: Maybe<Int>;
  talker?: Maybe<WeChatUserUpdateOneWithoutMessageInput>;
  createTime?: Maybe<DateTimeInput>;
  chatRoom?: Maybe<ChatRoomUpdateOneWithoutMessageInput>;
  content?: Maybe<ContentUpdateOneInput>;
}

export interface MessageCreateInput {
  id?: Maybe<ID_Input>;
  msgSvrId?: Maybe<String>;
  isSend?: Maybe<Int>;
  type?: Maybe<Int>;
  talker?: Maybe<WeChatUserCreateOneWithoutMessageInput>;
  createTime?: Maybe<DateTimeInput>;
  chatRoom?: Maybe<ChatRoomCreateOneWithoutMessageInput>;
  content?: Maybe<ContentCreateOneInput>;
}

export interface ContentUpsertWithoutImageInput {
  update: ContentUpdateWithoutImageDataInput;
  create: ContentCreateWithoutImageInput;
}

export interface ContentUpdateWithoutImageDataInput {
  text?: Maybe<TextUpdateOneWithoutContentInput>;
  voice?: Maybe<VoiceUpdateOneWithoutContentInput>;
  video?: Maybe<VideoUpdateOneWithoutContentInput>;
  file?: Maybe<FileUpdateOneWithoutContentInput>;
  app?: Maybe<AppUpdateOneWithoutContentInput>;
}

export interface FileIndexSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FileIndexWhereInput>;
  AND?: Maybe<
    FileIndexSubscriptionWhereInput[] | FileIndexSubscriptionWhereInput
  >;
}

export interface FileCreateOneWithoutContentInput {
  create?: Maybe<FileCreateWithoutContentInput>;
  connect?: Maybe<FileWhereUniqueInput>;
}

export interface MessageCreateManyInput {
  create?: Maybe<MessageCreateInput[] | MessageCreateInput>;
  connect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
}

export interface ContentCreateWithoutVideoInput {
  id?: Maybe<ID_Input>;
  text?: Maybe<TextCreateOneWithoutContentInput>;
  image?: Maybe<ImageCreateOneWithoutContentInput>;
  voice?: Maybe<VoiceCreateOneWithoutContentInput>;
  file?: Maybe<FileCreateOneWithoutContentInput>;
  app?: Maybe<AppCreateOneWithoutContentInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface WeChatUserPreviousValues {
  id: ID_Output;
  username: String;
  alias?: String;
  conRemark?: String;
  nickname?: String;
}

export interface WeChatUserPreviousValuesPromise
  extends Promise<WeChatUserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  username: () => Promise<String>;
  alias: () => Promise<String>;
  conRemark: () => Promise<String>;
  nickname: () => Promise<String>;
}

export interface WeChatUserPreviousValuesSubscription
  extends Promise<AsyncIterator<WeChatUserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  username: () => Promise<AsyncIterator<String>>;
  alias: () => Promise<AsyncIterator<String>>;
  conRemark: () => Promise<AsyncIterator<String>>;
  nickname: () => Promise<AsyncIterator<String>>;
}

export interface AggregateContact {
  count: Int;
}

export interface AggregateContactPromise
  extends Promise<AggregateContact>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateContactSubscription
  extends Promise<AsyncIterator<AggregateContact>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ContentConnection {
  pageInfo: PageInfo;
  edges: ContentEdge[];
}

export interface ContentConnectionPromise
  extends Promise<ContentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ContentEdge>>() => T;
  aggregate: <T = AggregateContentPromise>() => T;
}

export interface ContentConnectionSubscription
  extends Promise<AsyncIterator<ContentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ContentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateContentSubscription>() => T;
}

export interface VoicePreviousValues {
  id: ID_Output;
  voiceLength?: Int;
}

export interface VoicePreviousValuesPromise
  extends Promise<VoicePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  voiceLength: () => Promise<Int>;
}

export interface VoicePreviousValuesSubscription
  extends Promise<AsyncIterator<VoicePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  voiceLength: () => Promise<AsyncIterator<Int>>;
}

export interface Url {
  id: ID_Output;
  url: String;
}

export interface UrlPromise extends Promise<Url>, Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
  fileIndex: <T = FileIndexPromise>() => T;
}

export interface UrlSubscription
  extends Promise<AsyncIterator<Url>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
  fileIndex: <T = FileIndexSubscription>() => T;
}

export interface UrlNullablePromise extends Promise<Url | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
  fileIndex: <T = FileIndexPromise>() => T;
}

export interface ContactEdge {
  node: Contact;
  cursor: String;
}

export interface ContactEdgePromise extends Promise<ContactEdge>, Fragmentable {
  node: <T = ContactPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ContactEdgeSubscription
  extends Promise<AsyncIterator<ContactEdge>>,
    Fragmentable {
  node: <T = ContactSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AppConnection {
  pageInfo: PageInfo;
  edges: AppEdge[];
}

export interface AppConnectionPromise
  extends Promise<AppConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AppEdge>>() => T;
  aggregate: <T = AggregateAppPromise>() => T;
}

export interface AppConnectionSubscription
  extends Promise<AsyncIterator<AppConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AppEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAppSubscription>() => T;
}

export interface AggregateWeChatUser {
  count: Int;
}

export interface AggregateWeChatUserPromise
  extends Promise<AggregateWeChatUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWeChatUserSubscription
  extends Promise<AsyncIterator<AggregateWeChatUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface WeChatSubscriptionPayload {
  mutation: MutationType;
  node: WeChat;
  updatedFields: String[];
  previousValues: WeChatPreviousValues;
}

export interface WeChatSubscriptionPayloadPromise
  extends Promise<WeChatSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WeChatPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WeChatPreviousValuesPromise>() => T;
}

export interface WeChatSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WeChatSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WeChatSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WeChatPreviousValuesSubscription>() => T;
}

export interface WeChatUserConnection {
  pageInfo: PageInfo;
  edges: WeChatUserEdge[];
}

export interface WeChatUserConnectionPromise
  extends Promise<WeChatUserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WeChatUserEdge>>() => T;
  aggregate: <T = AggregateWeChatUserPromise>() => T;
}

export interface WeChatUserConnectionSubscription
  extends Promise<AsyncIterator<WeChatUserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<WeChatUserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateWeChatUserSubscription>() => T;
}

export interface ContactConnection {
  pageInfo: PageInfo;
  edges: ContactEdge[];
}

export interface ContactConnectionPromise
  extends Promise<ContactConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ContactEdge>>() => T;
  aggregate: <T = AggregateContactPromise>() => T;
}

export interface ContactConnectionSubscription
  extends Promise<AsyncIterator<ContactConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ContactEdgeSubscription>>>() => T;
  aggregate: <T = AggregateContactSubscription>() => T;
}

export interface WeChatEdge {
  node: WeChat;
  cursor: String;
}

export interface WeChatEdgePromise extends Promise<WeChatEdge>, Fragmentable {
  node: <T = WeChatPromise>() => T;
  cursor: () => Promise<String>;
}

export interface WeChatEdgeSubscription
  extends Promise<AsyncIterator<WeChatEdge>>,
    Fragmentable {
  node: <T = WeChatSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Voice {
  id: ID_Output;
  voiceLength?: Int;
}

export interface VoicePromise extends Promise<Voice>, Fragmentable {
  id: () => Promise<ID_Output>;
  fileName: <T = FileIndexPromise>() => T;
  voiceLength: () => Promise<Int>;
  content: <T = ContentPromise>() => T;
}

export interface VoiceSubscription
  extends Promise<AsyncIterator<Voice>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fileName: <T = FileIndexSubscription>() => T;
  voiceLength: () => Promise<AsyncIterator<Int>>;
  content: <T = ContentSubscription>() => T;
}

export interface VoiceNullablePromise
  extends Promise<Voice | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fileName: <T = FileIndexPromise>() => T;
  voiceLength: () => Promise<Int>;
  content: <T = ContentPromise>() => T;
}

export interface AggregateVoice {
  count: Int;
}

export interface AggregateVoicePromise
  extends Promise<AggregateVoice>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVoiceSubscription
  extends Promise<AsyncIterator<AggregateVoice>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface App {
  id: ID_Output;
  xml?: Json;
}

export interface AppPromise extends Promise<App>, Fragmentable {
  id: () => Promise<ID_Output>;
  xml: () => Promise<Json>;
  content: <T = ContentPromise>() => T;
}

export interface AppSubscription
  extends Promise<AsyncIterator<App>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  xml: () => Promise<AsyncIterator<Json>>;
  content: <T = ContentSubscription>() => T;
}

export interface AppNullablePromise extends Promise<App | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  xml: () => Promise<Json>;
  content: <T = ContentPromise>() => T;
}

export interface VoiceConnection {
  pageInfo: PageInfo;
  edges: VoiceEdge[];
}

export interface VoiceConnectionPromise
  extends Promise<VoiceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VoiceEdge>>() => T;
  aggregate: <T = AggregateVoicePromise>() => T;
}

export interface VoiceConnectionSubscription
  extends Promise<AsyncIterator<VoiceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VoiceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVoiceSubscription>() => T;
}

export interface AppSubscriptionPayload {
  mutation: MutationType;
  node: App;
  updatedFields: String[];
  previousValues: AppPreviousValues;
}

export interface AppSubscriptionPayloadPromise
  extends Promise<AppSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AppPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AppPreviousValuesPromise>() => T;
}

export interface AppSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AppSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AppSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AppPreviousValuesSubscription>() => T;
}

export interface AggregateVideo {
  count: Int;
}

export interface AggregateVideoPromise
  extends Promise<AggregateVideo>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVideoSubscription
  extends Promise<AsyncIterator<AggregateVideo>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AppPreviousValues {
  id: ID_Output;
  xml?: Json;
}

export interface AppPreviousValuesPromise
  extends Promise<AppPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  xml: () => Promise<Json>;
}

export interface AppPreviousValuesSubscription
  extends Promise<AsyncIterator<AppPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  xml: () => Promise<AsyncIterator<Json>>;
}

export interface VideoConnection {
  pageInfo: PageInfo;
  edges: VideoEdge[];
}

export interface VideoConnectionPromise
  extends Promise<VideoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VideoEdge>>() => T;
  aggregate: <T = AggregateVideoPromise>() => T;
}

export interface VideoConnectionSubscription
  extends Promise<AsyncIterator<VideoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VideoEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVideoSubscription>() => T;
}

export interface AggregateChatRoom {
  count: Int;
}

export interface AggregateChatRoomPromise
  extends Promise<AggregateChatRoom>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateChatRoomSubscription
  extends Promise<AsyncIterator<AggregateChatRoom>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AvatarSubscriptionPayload {
  mutation: MutationType;
  node: Avatar;
  updatedFields: String[];
  previousValues: AvatarPreviousValues;
}

export interface AvatarSubscriptionPayloadPromise
  extends Promise<AvatarSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AvatarPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AvatarPreviousValuesPromise>() => T;
}

export interface AvatarSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AvatarSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AvatarSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AvatarPreviousValuesSubscription>() => T;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface AvatarPreviousValues {
  id: ID_Output;
}

export interface AvatarPreviousValuesPromise
  extends Promise<AvatarPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface AvatarPreviousValuesSubscription
  extends Promise<AsyncIterator<AvatarPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface WeChat {
  id: ID_Output;
}

export interface WeChatPromise extends Promise<WeChat>, Fragmentable {
  id: () => Promise<ID_Output>;
  weChatOwner: <T = WeChatUserPromise>() => T;
  weChatUsers: <T = FragmentableArray<WeChatUser>>(args?: {
    where?: WeChatUserWhereInput;
    orderBy?: WeChatUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  chatRooms: <T = FragmentableArray<ChatRoom>>(args?: {
    where?: ChatRoomWhereInput;
    orderBy?: ChatRoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  messages: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface WeChatSubscription
  extends Promise<AsyncIterator<WeChat>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  weChatOwner: <T = WeChatUserSubscription>() => T;
  weChatUsers: <T = Promise<AsyncIterator<WeChatUserSubscription>>>(args?: {
    where?: WeChatUserWhereInput;
    orderBy?: WeChatUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  chatRooms: <T = Promise<AsyncIterator<ChatRoomSubscription>>>(args?: {
    where?: ChatRoomWhereInput;
    orderBy?: ChatRoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  messages: <T = Promise<AsyncIterator<MessageSubscription>>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface WeChatNullablePromise
  extends Promise<WeChat | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  weChatOwner: <T = WeChatUserPromise>() => T;
  weChatUsers: <T = FragmentableArray<WeChatUser>>(args?: {
    where?: WeChatUserWhereInput;
    orderBy?: WeChatUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  chatRooms: <T = FragmentableArray<ChatRoom>>(args?: {
    where?: ChatRoomWhereInput;
    orderBy?: ChatRoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  messages: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ChatRoomEdge {
  node: ChatRoom;
  cursor: String;
}

export interface ChatRoomEdgePromise
  extends Promise<ChatRoomEdge>,
    Fragmentable {
  node: <T = ChatRoomPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ChatRoomEdgeSubscription
  extends Promise<AsyncIterator<ChatRoomEdge>>,
    Fragmentable {
  node: <T = ChatRoomSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface User {
  id: ID_Output;
  email: String;
  name: String;
  password: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  name: () => Promise<String>;
  password: () => Promise<String>;
  weChat: <T = FragmentableArray<WeChat>>(args?: {
    where?: WeChatWhereInput;
    orderBy?: WeChatOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  weChat: <T = Promise<AsyncIterator<WeChatSubscription>>>(args?: {
    where?: WeChatWhereInput;
    orderBy?: WeChatOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  name: () => Promise<String>;
  password: () => Promise<String>;
  weChat: <T = FragmentableArray<WeChat>>(args?: {
    where?: WeChatWhereInput;
    orderBy?: WeChatOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ChatRoomSubscriptionPayload {
  mutation: MutationType;
  node: ChatRoom;
  updatedFields: String[];
  previousValues: ChatRoomPreviousValues;
}

export interface ChatRoomSubscriptionPayloadPromise
  extends Promise<ChatRoomSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ChatRoomPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ChatRoomPreviousValuesPromise>() => T;
}

export interface ChatRoomSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ChatRoomSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ChatRoomSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ChatRoomPreviousValuesSubscription>() => T;
}

export interface UrlEdge {
  node: Url;
  cursor: String;
}

export interface UrlEdgePromise extends Promise<UrlEdge>, Fragmentable {
  node: <T = UrlPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UrlEdgeSubscription
  extends Promise<AsyncIterator<UrlEdge>>,
    Fragmentable {
  node: <T = UrlSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ChatRoomPreviousValues {
  id: ID_Output;
  username: String;
  nickname?: String;
  displayName?: String;
  modifyTime?: DateTimeOutput;
}

export interface ChatRoomPreviousValuesPromise
  extends Promise<ChatRoomPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  username: () => Promise<String>;
  nickname: () => Promise<String>;
  displayName: () => Promise<String>;
  modifyTime: () => Promise<DateTimeOutput>;
}

export interface ChatRoomPreviousValuesSubscription
  extends Promise<AsyncIterator<ChatRoomPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  username: () => Promise<AsyncIterator<String>>;
  nickname: () => Promise<AsyncIterator<String>>;
  displayName: () => Promise<AsyncIterator<String>>;
  modifyTime: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateText {
  count: Int;
}

export interface AggregateTextPromise
  extends Promise<AggregateText>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTextSubscription
  extends Promise<AsyncIterator<AggregateText>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ChatRoomConnection {
  pageInfo: PageInfo;
  edges: ChatRoomEdge[];
}

export interface ChatRoomConnectionPromise
  extends Promise<ChatRoomConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ChatRoomEdge>>() => T;
  aggregate: <T = AggregateChatRoomPromise>() => T;
}

export interface ChatRoomConnectionSubscription
  extends Promise<AsyncIterator<ChatRoomConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ChatRoomEdgeSubscription>>>() => T;
  aggregate: <T = AggregateChatRoomSubscription>() => T;
}

export interface TextConnection {
  pageInfo: PageInfo;
  edges: TextEdge[];
}

export interface TextConnectionPromise
  extends Promise<TextConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TextEdge>>() => T;
  aggregate: <T = AggregateTextPromise>() => T;
}

export interface TextConnectionSubscription
  extends Promise<AsyncIterator<TextConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TextEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTextSubscription>() => T;
}

export interface ContactSubscriptionPayload {
  mutation: MutationType;
  node: Contact;
  updatedFields: String[];
  previousValues: ContactPreviousValues;
}

export interface ContactSubscriptionPayloadPromise
  extends Promise<ContactSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ContactPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ContactPreviousValuesPromise>() => T;
}

export interface ContactSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ContactSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ContactSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ContactPreviousValuesSubscription>() => T;
}

export interface AggregateMessage {
  count: Int;
}

export interface AggregateMessagePromise
  extends Promise<AggregateMessage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMessageSubscription
  extends Promise<AsyncIterator<AggregateMessage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ContactPreviousValues {
  id: ID_Output;
  type: String;
}

export interface ContactPreviousValuesPromise
  extends Promise<ContactPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<String>;
}

export interface ContactPreviousValuesSubscription
  extends Promise<AsyncIterator<ContactPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<String>>;
}

export interface MessageConnection {
  pageInfo: PageInfo;
  edges: MessageEdge[];
}

export interface MessageConnectionPromise
  extends Promise<MessageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MessageEdge>>() => T;
  aggregate: <T = AggregateMessagePromise>() => T;
}

export interface MessageConnectionSubscription
  extends Promise<AsyncIterator<MessageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MessageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMessageSubscription>() => T;
}

export interface Video {
  id: ID_Output;
  videolength?: Int;
}

export interface VideoPromise extends Promise<Video>, Fragmentable {
  id: () => Promise<ID_Output>;
  fileName: <T = FileIndexPromise>() => T;
  thumbnailImg: <T = FileIndexPromise>() => T;
  videolength: () => Promise<Int>;
  content: <T = ContentPromise>() => T;
}

export interface VideoSubscription
  extends Promise<AsyncIterator<Video>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fileName: <T = FileIndexSubscription>() => T;
  thumbnailImg: <T = FileIndexSubscription>() => T;
  videolength: () => Promise<AsyncIterator<Int>>;
  content: <T = ContentSubscription>() => T;
}

export interface VideoNullablePromise
  extends Promise<Video | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fileName: <T = FileIndexPromise>() => T;
  thumbnailImg: <T = FileIndexPromise>() => T;
  videolength: () => Promise<Int>;
  content: <T = ContentPromise>() => T;
}

export interface ImageEdge {
  node: Image;
  cursor: String;
}

export interface ImageEdgePromise extends Promise<ImageEdge>, Fragmentable {
  node: <T = ImagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ImageEdgeSubscription
  extends Promise<AsyncIterator<ImageEdge>>,
    Fragmentable {
  node: <T = ImageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ContentSubscriptionPayload {
  mutation: MutationType;
  node: Content;
  updatedFields: String[];
  previousValues: ContentPreviousValues;
}

export interface ContentSubscriptionPayloadPromise
  extends Promise<ContentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ContentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ContentPreviousValuesPromise>() => T;
}

export interface ContentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ContentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ContentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ContentPreviousValuesSubscription>() => T;
}

export interface FileIndex {
  id: ID_Output;
  fileName: String;
  mimetype: String;
  size: Int;
}

export interface FileIndexPromise extends Promise<FileIndex>, Fragmentable {
  id: () => Promise<ID_Output>;
  fileName: () => Promise<String>;
  mimetype: () => Promise<String>;
  size: () => Promise<Int>;
  urls: <T = FragmentableArray<Url>>(args?: {
    where?: UrlWhereInput;
    orderBy?: UrlOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface FileIndexSubscription
  extends Promise<AsyncIterator<FileIndex>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fileName: () => Promise<AsyncIterator<String>>;
  mimetype: () => Promise<AsyncIterator<String>>;
  size: () => Promise<AsyncIterator<Int>>;
  urls: <T = Promise<AsyncIterator<UrlSubscription>>>(args?: {
    where?: UrlWhereInput;
    orderBy?: UrlOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface FileIndexNullablePromise
  extends Promise<FileIndex | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fileName: () => Promise<String>;
  mimetype: () => Promise<String>;
  size: () => Promise<Int>;
  urls: <T = FragmentableArray<Url>>(args?: {
    where?: UrlWhereInput;
    orderBy?: UrlOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ContentPreviousValues {
  id: ID_Output;
}

export interface ContentPreviousValuesPromise
  extends Promise<ContentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface ContentPreviousValuesSubscription
  extends Promise<AsyncIterator<ContentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface FileIndexEdge {
  node: FileIndex;
  cursor: String;
}

export interface FileIndexEdgePromise
  extends Promise<FileIndexEdge>,
    Fragmentable {
  node: <T = FileIndexPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FileIndexEdgeSubscription
  extends Promise<AsyncIterator<FileIndexEdge>>,
    Fragmentable {
  node: <T = FileIndexSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Contact {
  id: ID_Output;
  type: String;
}

export interface ContactPromise extends Promise<Contact>, Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<String>;
  weChatUser: <T = FragmentableArray<WeChatUser>>(args?: {
    where?: WeChatUserWhereInput;
    orderBy?: WeChatUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ContactSubscription
  extends Promise<AsyncIterator<Contact>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<String>>;
  weChatUser: <T = Promise<AsyncIterator<WeChatUserSubscription>>>(args?: {
    where?: WeChatUserWhereInput;
    orderBy?: WeChatUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ContactNullablePromise
  extends Promise<Contact | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<String>;
  weChatUser: <T = FragmentableArray<WeChatUser>>(args?: {
    where?: WeChatUserWhereInput;
    orderBy?: WeChatUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AggregateFileGroup {
  count: Int;
}

export interface AggregateFileGroupPromise
  extends Promise<AggregateFileGroup>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFileGroupSubscription
  extends Promise<AsyncIterator<AggregateFileGroup>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FileSubscriptionPayload {
  mutation: MutationType;
  node: File;
  updatedFields: String[];
  previousValues: FilePreviousValues;
}

export interface FileSubscriptionPayloadPromise
  extends Promise<FileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FilePreviousValuesPromise>() => T;
}

export interface FileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FilePreviousValuesSubscription>() => T;
}

export interface FileGroupConnection {
  pageInfo: PageInfo;
  edges: FileGroupEdge[];
}

export interface FileGroupConnectionPromise
  extends Promise<FileGroupConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FileGroupEdge>>() => T;
  aggregate: <T = AggregateFileGroupPromise>() => T;
}

export interface FileGroupConnectionSubscription
  extends Promise<AsyncIterator<FileGroupConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FileGroupEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFileGroupSubscription>() => T;
}

export interface FilePreviousValues {
  id: ID_Output;
  size?: Int;
}

export interface FilePreviousValuesPromise
  extends Promise<FilePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  size: () => Promise<Int>;
}

export interface FilePreviousValuesSubscription
  extends Promise<AsyncIterator<FilePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  size: () => Promise<AsyncIterator<Int>>;
}

export interface FileGroup {
  id: ID_Output;
  name: String;
}

export interface FileGroupPromise extends Promise<FileGroup>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  fileIndexes: <T = FragmentableArray<FileIndex>>(args?: {
    where?: FileIndexWhereInput;
    orderBy?: FileIndexOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface FileGroupSubscription
  extends Promise<AsyncIterator<FileGroup>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  fileIndexes: <T = Promise<AsyncIterator<FileIndexSubscription>>>(args?: {
    where?: FileIndexWhereInput;
    orderBy?: FileIndexOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface FileGroupNullablePromise
  extends Promise<FileGroup | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  fileIndexes: <T = FragmentableArray<FileIndex>>(args?: {
    where?: FileIndexWhereInput;
    orderBy?: FileIndexOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface File {
  id: ID_Output;
  size?: Int;
}

export interface FilePromise extends Promise<File>, Fragmentable {
  id: () => Promise<ID_Output>;
  fileName: <T = FileIndexPromise>() => T;
  size: () => Promise<Int>;
  content: <T = ContentPromise>() => T;
}

export interface FileSubscription
  extends Promise<AsyncIterator<File>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fileName: <T = FileIndexSubscription>() => T;
  size: () => Promise<AsyncIterator<Int>>;
  content: <T = ContentSubscription>() => T;
}

export interface FileNullablePromise
  extends Promise<File | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fileName: <T = FileIndexPromise>() => T;
  size: () => Promise<Int>;
  content: <T = ContentPromise>() => T;
}

export interface FileEdge {
  node: File;
  cursor: String;
}

export interface FileEdgePromise extends Promise<FileEdge>, Fragmentable {
  node: <T = FilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface FileEdgeSubscription
  extends Promise<AsyncIterator<FileEdge>>,
    Fragmentable {
  node: <T = FileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FileGroupSubscriptionPayload {
  mutation: MutationType;
  node: FileGroup;
  updatedFields: String[];
  previousValues: FileGroupPreviousValues;
}

export interface FileGroupSubscriptionPayloadPromise
  extends Promise<FileGroupSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FileGroupPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FileGroupPreviousValuesPromise>() => T;
}

export interface FileGroupSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FileGroupSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FileGroupSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FileGroupPreviousValuesSubscription>() => T;
}

export interface AggregateContent {
  count: Int;
}

export interface AggregateContentPromise
  extends Promise<AggregateContent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateContentSubscription
  extends Promise<AsyncIterator<AggregateContent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FileGroupPreviousValues {
  id: ID_Output;
  name: String;
}

export interface FileGroupPreviousValuesPromise
  extends Promise<FileGroupPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface FileGroupPreviousValuesSubscription
  extends Promise<AsyncIterator<FileGroupPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface Message {
  id: ID_Output;
  msgSvrId?: String;
  isSend?: Int;
  type?: Int;
  createTime?: DateTimeOutput;
}

export interface MessagePromise extends Promise<Message>, Fragmentable {
  id: () => Promise<ID_Output>;
  msgSvrId: () => Promise<String>;
  isSend: () => Promise<Int>;
  type: () => Promise<Int>;
  talker: <T = WeChatUserPromise>() => T;
  createTime: () => Promise<DateTimeOutput>;
  chatRoom: <T = ChatRoomPromise>() => T;
  content: <T = ContentPromise>() => T;
}

export interface MessageSubscription
  extends Promise<AsyncIterator<Message>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  msgSvrId: () => Promise<AsyncIterator<String>>;
  isSend: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<Int>>;
  talker: <T = WeChatUserSubscription>() => T;
  createTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  chatRoom: <T = ChatRoomSubscription>() => T;
  content: <T = ContentSubscription>() => T;
}

export interface MessageNullablePromise
  extends Promise<Message | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  msgSvrId: () => Promise<String>;
  isSend: () => Promise<Int>;
  type: () => Promise<Int>;
  talker: <T = WeChatUserPromise>() => T;
  createTime: () => Promise<DateTimeOutput>;
  chatRoom: <T = ChatRoomPromise>() => T;
  content: <T = ContentPromise>() => T;
}

export interface AggregateWeChat {
  count: Int;
}

export interface AggregateWeChatPromise
  extends Promise<AggregateWeChat>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWeChatSubscription
  extends Promise<AsyncIterator<AggregateWeChat>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FileIndexSubscriptionPayload {
  mutation: MutationType;
  node: FileIndex;
  updatedFields: String[];
  previousValues: FileIndexPreviousValues;
}

export interface FileIndexSubscriptionPayloadPromise
  extends Promise<FileIndexSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FileIndexPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FileIndexPreviousValuesPromise>() => T;
}

export interface FileIndexSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FileIndexSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FileIndexSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FileIndexPreviousValuesSubscription>() => T;
}

export interface VoiceEdge {
  node: Voice;
  cursor: String;
}

export interface VoiceEdgePromise extends Promise<VoiceEdge>, Fragmentable {
  node: <T = VoicePromise>() => T;
  cursor: () => Promise<String>;
}

export interface VoiceEdgeSubscription
  extends Promise<AsyncIterator<VoiceEdge>>,
    Fragmentable {
  node: <T = VoiceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FileIndexPreviousValues {
  id: ID_Output;
  fileName: String;
  mimetype: String;
  size: Int;
}

export interface FileIndexPreviousValuesPromise
  extends Promise<FileIndexPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fileName: () => Promise<String>;
  mimetype: () => Promise<String>;
  size: () => Promise<Int>;
}

export interface FileIndexPreviousValuesSubscription
  extends Promise<AsyncIterator<FileIndexPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fileName: () => Promise<AsyncIterator<String>>;
  mimetype: () => Promise<AsyncIterator<String>>;
  size: () => Promise<AsyncIterator<Int>>;
}

export interface VideoEdge {
  node: Video;
  cursor: String;
}

export interface VideoEdgePromise extends Promise<VideoEdge>, Fragmentable {
  node: <T = VideoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface VideoEdgeSubscription
  extends Promise<AsyncIterator<VideoEdge>>,
    Fragmentable {
  node: <T = VideoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateApp {
  count: Int;
}

export interface AggregateAppPromise
  extends Promise<AggregateApp>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAppSubscription
  extends Promise<AsyncIterator<AggregateApp>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ImageSubscriptionPayload {
  mutation: MutationType;
  node: Image;
  updatedFields: String[];
  previousValues: ImagePreviousValues;
}

export interface ImageSubscriptionPayloadPromise
  extends Promise<ImageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ImagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ImagePreviousValuesPromise>() => T;
}

export interface ImageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ImageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ImageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ImagePreviousValuesSubscription>() => T;
}

export interface AppEdge {
  node: App;
  cursor: String;
}

export interface AppEdgePromise extends Promise<AppEdge>, Fragmentable {
  node: <T = AppPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AppEdgeSubscription
  extends Promise<AsyncIterator<AppEdge>>,
    Fragmentable {
  node: <T = AppSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ImagePreviousValues {
  id: ID_Output;
}

export interface ImagePreviousValuesPromise
  extends Promise<ImagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface ImagePreviousValuesSubscription
  extends Promise<AsyncIterator<ImagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface UrlConnection {
  pageInfo: PageInfo;
  edges: UrlEdge[];
}

export interface UrlConnectionPromise
  extends Promise<UrlConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UrlEdge>>() => T;
  aggregate: <T = AggregateUrlPromise>() => T;
}

export interface UrlConnectionSubscription
  extends Promise<AsyncIterator<UrlConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UrlEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUrlSubscription>() => T;
}

export interface WeChatUser {
  id: ID_Output;
  username: String;
  alias?: String;
  conRemark?: String;
  nickname?: String;
}

export interface WeChatUserPromise extends Promise<WeChatUser>, Fragmentable {
  id: () => Promise<ID_Output>;
  username: () => Promise<String>;
  alias: () => Promise<String>;
  conRemark: () => Promise<String>;
  nickname: () => Promise<String>;
  avatar: <T = AvatarPromise>() => T;
  message: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  haveChatRoom: <T = FragmentableArray<ChatRoom>>(args?: {
    where?: ChatRoomWhereInput;
    orderBy?: ChatRoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  joinChatRoom: <T = FragmentableArray<ChatRoom>>(args?: {
    where?: ChatRoomWhereInput;
    orderBy?: ChatRoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  contact: <T = ContactPromise>() => T;
}

export interface WeChatUserSubscription
  extends Promise<AsyncIterator<WeChatUser>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  username: () => Promise<AsyncIterator<String>>;
  alias: () => Promise<AsyncIterator<String>>;
  conRemark: () => Promise<AsyncIterator<String>>;
  nickname: () => Promise<AsyncIterator<String>>;
  avatar: <T = AvatarSubscription>() => T;
  message: <T = Promise<AsyncIterator<MessageSubscription>>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  haveChatRoom: <T = Promise<AsyncIterator<ChatRoomSubscription>>>(args?: {
    where?: ChatRoomWhereInput;
    orderBy?: ChatRoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  joinChatRoom: <T = Promise<AsyncIterator<ChatRoomSubscription>>>(args?: {
    where?: ChatRoomWhereInput;
    orderBy?: ChatRoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  contact: <T = ContactSubscription>() => T;
}

export interface WeChatUserNullablePromise
  extends Promise<WeChatUser | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  username: () => Promise<String>;
  alias: () => Promise<String>;
  conRemark: () => Promise<String>;
  nickname: () => Promise<String>;
  avatar: <T = AvatarPromise>() => T;
  message: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  haveChatRoom: <T = FragmentableArray<ChatRoom>>(args?: {
    where?: ChatRoomWhereInput;
    orderBy?: ChatRoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  joinChatRoom: <T = FragmentableArray<ChatRoom>>(args?: {
    where?: ChatRoomWhereInput;
    orderBy?: ChatRoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  contact: <T = ContactPromise>() => T;
}

export interface Image {
  id: ID_Output;
}

export interface ImagePromise extends Promise<Image>, Fragmentable {
  id: () => Promise<ID_Output>;
  thumbnailImg: <T = FileIndexPromise>() => T;
  bigImg: <T = FileIndexPromise>() => T;
  content: <T = ContentPromise>() => T;
}

export interface ImageSubscription
  extends Promise<AsyncIterator<Image>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  thumbnailImg: <T = FileIndexSubscription>() => T;
  bigImg: <T = FileIndexSubscription>() => T;
  content: <T = ContentSubscription>() => T;
}

export interface ImageNullablePromise
  extends Promise<Image | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  thumbnailImg: <T = FileIndexPromise>() => T;
  bigImg: <T = FileIndexPromise>() => T;
  content: <T = ContentPromise>() => T;
}

export interface MessageSubscriptionPayload {
  mutation: MutationType;
  node: Message;
  updatedFields: String[];
  previousValues: MessagePreviousValues;
}

export interface MessageSubscriptionPayloadPromise
  extends Promise<MessageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MessagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MessagePreviousValuesPromise>() => T;
}

export interface MessageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MessageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MessageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MessagePreviousValuesSubscription>() => T;
}

export interface AggregateImage {
  count: Int;
}

export interface AggregateImagePromise
  extends Promise<AggregateImage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateImageSubscription
  extends Promise<AsyncIterator<AggregateImage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MessagePreviousValues {
  id: ID_Output;
  msgSvrId?: String;
  isSend?: Int;
  type?: Int;
  createTime?: DateTimeOutput;
}

export interface MessagePreviousValuesPromise
  extends Promise<MessagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  msgSvrId: () => Promise<String>;
  isSend: () => Promise<Int>;
  type: () => Promise<Int>;
  createTime: () => Promise<DateTimeOutput>;
}

export interface MessagePreviousValuesSubscription
  extends Promise<AsyncIterator<MessagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  msgSvrId: () => Promise<AsyncIterator<String>>;
  isSend: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<Int>>;
  createTime: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateFileIndex {
  count: Int;
}

export interface AggregateFileIndexPromise
  extends Promise<AggregateFileIndex>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFileIndexSubscription
  extends Promise<AsyncIterator<AggregateFileIndex>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ChatRoom {
  id: ID_Output;
  username: String;
  nickname?: String;
  displayName?: String;
  modifyTime?: DateTimeOutput;
}

export interface ChatRoomPromise extends Promise<ChatRoom>, Fragmentable {
  id: () => Promise<ID_Output>;
  username: () => Promise<String>;
  nickname: () => Promise<String>;
  displayName: () => Promise<String>;
  owner: <T = WeChatUserPromise>() => T;
  memberList: <T = FragmentableArray<WeChatUser>>(args?: {
    where?: WeChatUserWhereInput;
    orderBy?: WeChatUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  modifyTime: () => Promise<DateTimeOutput>;
  avatar: <T = AvatarPromise>() => T;
  message: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ChatRoomSubscription
  extends Promise<AsyncIterator<ChatRoom>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  username: () => Promise<AsyncIterator<String>>;
  nickname: () => Promise<AsyncIterator<String>>;
  displayName: () => Promise<AsyncIterator<String>>;
  owner: <T = WeChatUserSubscription>() => T;
  memberList: <T = Promise<AsyncIterator<WeChatUserSubscription>>>(args?: {
    where?: WeChatUserWhereInput;
    orderBy?: WeChatUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  modifyTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  avatar: <T = AvatarSubscription>() => T;
  message: <T = Promise<AsyncIterator<MessageSubscription>>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ChatRoomNullablePromise
  extends Promise<ChatRoom | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  username: () => Promise<String>;
  nickname: () => Promise<String>;
  displayName: () => Promise<String>;
  owner: <T = WeChatUserPromise>() => T;
  memberList: <T = FragmentableArray<WeChatUser>>(args?: {
    where?: WeChatUserWhereInput;
    orderBy?: WeChatUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  modifyTime: () => Promise<DateTimeOutput>;
  avatar: <T = AvatarPromise>() => T;
  message: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface FileGroupEdge {
  node: FileGroup;
  cursor: String;
}

export interface FileGroupEdgePromise
  extends Promise<FileGroupEdge>,
    Fragmentable {
  node: <T = FileGroupPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FileGroupEdgeSubscription
  extends Promise<AsyncIterator<FileGroupEdge>>,
    Fragmentable {
  node: <T = FileGroupSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TextSubscriptionPayload {
  mutation: MutationType;
  node: Text;
  updatedFields: String[];
  previousValues: TextPreviousValues;
}

export interface TextSubscriptionPayloadPromise
  extends Promise<TextSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TextPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TextPreviousValuesPromise>() => T;
}

export interface TextSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TextSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TextSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TextPreviousValuesSubscription>() => T;
}

export interface AggregateFile {
  count: Int;
}

export interface AggregateFilePromise
  extends Promise<AggregateFile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFileSubscription
  extends Promise<AsyncIterator<AggregateFile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TextPreviousValues {
  id: ID_Output;
  textMsg: String;
}

export interface TextPreviousValuesPromise
  extends Promise<TextPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  textMsg: () => Promise<String>;
}

export interface TextPreviousValuesSubscription
  extends Promise<AsyncIterator<TextPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  textMsg: () => Promise<AsyncIterator<String>>;
}

export interface ContentEdge {
  node: Content;
  cursor: String;
}

export interface ContentEdgePromise extends Promise<ContentEdge>, Fragmentable {
  node: <T = ContentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ContentEdgeSubscription
  extends Promise<AsyncIterator<ContentEdge>>,
    Fragmentable {
  node: <T = ContentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAvatar {
  count: Int;
}

export interface AggregateAvatarPromise
  extends Promise<AggregateAvatar>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAvatarSubscription
  extends Promise<AsyncIterator<AggregateAvatar>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface WeChatConnection {
  pageInfo: PageInfo;
  edges: WeChatEdge[];
}

export interface WeChatConnectionPromise
  extends Promise<WeChatConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WeChatEdge>>() => T;
  aggregate: <T = AggregateWeChatPromise>() => T;
}

export interface WeChatConnectionSubscription
  extends Promise<AsyncIterator<WeChatConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<WeChatEdgeSubscription>>>() => T;
  aggregate: <T = AggregateWeChatSubscription>() => T;
}

export interface UrlSubscriptionPayload {
  mutation: MutationType;
  node: Url;
  updatedFields: String[];
  previousValues: UrlPreviousValues;
}

export interface UrlSubscriptionPayloadPromise
  extends Promise<UrlSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UrlPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UrlPreviousValuesPromise>() => T;
}

export interface UrlSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UrlSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UrlSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UrlPreviousValuesSubscription>() => T;
}

export interface Content {
  id: ID_Output;
}

export interface ContentPromise extends Promise<Content>, Fragmentable {
  id: () => Promise<ID_Output>;
  text: <T = TextPromise>() => T;
  image: <T = ImagePromise>() => T;
  voice: <T = VoicePromise>() => T;
  video: <T = VideoPromise>() => T;
  file: <T = FilePromise>() => T;
  app: <T = AppPromise>() => T;
}

export interface ContentSubscription
  extends Promise<AsyncIterator<Content>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: <T = TextSubscription>() => T;
  image: <T = ImageSubscription>() => T;
  voice: <T = VoiceSubscription>() => T;
  video: <T = VideoSubscription>() => T;
  file: <T = FileSubscription>() => T;
  app: <T = AppSubscription>() => T;
}

export interface ContentNullablePromise
  extends Promise<Content | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: <T = TextPromise>() => T;
  image: <T = ImagePromise>() => T;
  voice: <T = VoicePromise>() => T;
  video: <T = VideoPromise>() => T;
  file: <T = FilePromise>() => T;
  app: <T = AppPromise>() => T;
}

export interface UrlPreviousValues {
  id: ID_Output;
  url: String;
}

export interface UrlPreviousValuesPromise
  extends Promise<UrlPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
}

export interface UrlPreviousValuesSubscription
  extends Promise<AsyncIterator<UrlPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUrl {
  count: Int;
}

export interface AggregateUrlPromise
  extends Promise<AggregateUrl>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUrlSubscription
  extends Promise<AsyncIterator<AggregateUrl>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AvatarEdge {
  node: Avatar;
  cursor: String;
}

export interface AvatarEdgePromise extends Promise<AvatarEdge>, Fragmentable {
  node: <T = AvatarPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AvatarEdgeSubscription
  extends Promise<AsyncIterator<AvatarEdge>>,
    Fragmentable {
  node: <T = AvatarSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MessageEdge {
  node: Message;
  cursor: String;
}

export interface MessageEdgePromise extends Promise<MessageEdge>, Fragmentable {
  node: <T = MessagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface MessageEdgeSubscription
  extends Promise<AsyncIterator<MessageEdge>>,
    Fragmentable {
  node: <T = MessageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface FileIndexConnection {
  pageInfo: PageInfo;
  edges: FileIndexEdge[];
}

export interface FileIndexConnectionPromise
  extends Promise<FileIndexConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FileIndexEdge>>() => T;
  aggregate: <T = AggregateFileIndexPromise>() => T;
}

export interface FileIndexConnectionSubscription
  extends Promise<AsyncIterator<FileIndexConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FileIndexEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFileIndexSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  email: String;
  name: String;
  password: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  name: () => Promise<String>;
  password: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
}

export interface FileConnection {
  pageInfo: PageInfo;
  edges: FileEdge[];
}

export interface FileConnectionPromise
  extends Promise<FileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FileEdge>>() => T;
  aggregate: <T = AggregateFilePromise>() => T;
}

export interface FileConnectionSubscription
  extends Promise<AsyncIterator<FileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FileEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFileSubscription>() => T;
}

export interface AvatarConnection {
  pageInfo: PageInfo;
  edges: AvatarEdge[];
}

export interface AvatarConnectionPromise
  extends Promise<AvatarConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AvatarEdge>>() => T;
  aggregate: <T = AggregateAvatarPromise>() => T;
}

export interface AvatarConnectionSubscription
  extends Promise<AsyncIterator<AvatarConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AvatarEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAvatarSubscription>() => T;
}

export interface WeChatUserSubscriptionPayload {
  mutation: MutationType;
  node: WeChatUser;
  updatedFields: String[];
  previousValues: WeChatUserPreviousValues;
}

export interface WeChatUserSubscriptionPayloadPromise
  extends Promise<WeChatUserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WeChatUserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WeChatUserPreviousValuesPromise>() => T;
}

export interface WeChatUserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WeChatUserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WeChatUserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WeChatUserPreviousValuesSubscription>() => T;
}

export interface TextEdge {
  node: Text;
  cursor: String;
}

export interface TextEdgePromise extends Promise<TextEdge>, Fragmentable {
  node: <T = TextPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TextEdgeSubscription
  extends Promise<AsyncIterator<TextEdge>>,
    Fragmentable {
  node: <T = TextSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface VoiceSubscriptionPayload {
  mutation: MutationType;
  node: Voice;
  updatedFields: String[];
  previousValues: VoicePreviousValues;
}

export interface VoiceSubscriptionPayloadPromise
  extends Promise<VoiceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VoicePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VoicePreviousValuesPromise>() => T;
}

export interface VoiceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VoiceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VoiceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VoicePreviousValuesSubscription>() => T;
}

export interface Avatar {
  id: ID_Output;
}

export interface AvatarPromise extends Promise<Avatar>, Fragmentable {
  id: () => Promise<ID_Output>;
  thumbnailImg: <T = UrlPromise>() => T;
  bigImg: <T = UrlPromise>() => T;
}

export interface AvatarSubscription
  extends Promise<AsyncIterator<Avatar>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  thumbnailImg: <T = UrlSubscription>() => T;
  bigImg: <T = UrlSubscription>() => T;
}

export interface AvatarNullablePromise
  extends Promise<Avatar | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  thumbnailImg: <T = UrlPromise>() => T;
  bigImg: <T = UrlPromise>() => T;
}

export interface VideoPreviousValues {
  id: ID_Output;
  videolength?: Int;
}

export interface VideoPreviousValuesPromise
  extends Promise<VideoPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  videolength: () => Promise<Int>;
}

export interface VideoPreviousValuesSubscription
  extends Promise<AsyncIterator<VideoPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  videolength: () => Promise<AsyncIterator<Int>>;
}

export interface VideoSubscriptionPayload {
  mutation: MutationType;
  node: Video;
  updatedFields: String[];
  previousValues: VideoPreviousValues;
}

export interface VideoSubscriptionPayloadPromise
  extends Promise<VideoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VideoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VideoPreviousValuesPromise>() => T;
}

export interface VideoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VideoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VideoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VideoPreviousValuesSubscription>() => T;
}

export interface ImageConnection {
  pageInfo: PageInfo;
  edges: ImageEdge[];
}

export interface ImageConnectionPromise
  extends Promise<ImageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ImageEdge>>() => T;
  aggregate: <T = AggregateImagePromise>() => T;
}

export interface ImageConnectionSubscription
  extends Promise<AsyncIterator<ImageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ImageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateImageSubscription>() => T;
}

export interface Text {
  id: ID_Output;
  textMsg: String;
}

export interface TextPromise extends Promise<Text>, Fragmentable {
  id: () => Promise<ID_Output>;
  textMsg: () => Promise<String>;
  content: <T = ContentPromise>() => T;
}

export interface TextSubscription
  extends Promise<AsyncIterator<Text>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  textMsg: () => Promise<AsyncIterator<String>>;
  content: <T = ContentSubscription>() => T;
}

export interface TextNullablePromise
  extends Promise<Text | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  textMsg: () => Promise<String>;
  content: <T = ContentPromise>() => T;
}

export interface WeChatUserEdge {
  node: WeChatUser;
  cursor: String;
}

export interface WeChatUserEdgePromise
  extends Promise<WeChatUserEdge>,
    Fragmentable {
  node: <T = WeChatUserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface WeChatUserEdgeSubscription
  extends Promise<AsyncIterator<WeChatUserEdge>>,
    Fragmentable {
  node: <T = WeChatUserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface WeChatPreviousValues {
  id: ID_Output;
}

export interface WeChatPreviousValuesPromise
  extends Promise<WeChatPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface WeChatPreviousValuesSubscription
  extends Promise<AsyncIterator<WeChatPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Json = any;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

export type Long = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "WeChat",
    embedded: false
  },
  {
    name: "WeChatUser",
    embedded: false
  },
  {
    name: "ChatRoom",
    embedded: false
  },
  {
    name: "Avatar",
    embedded: false
  },
  {
    name: "Contact",
    embedded: false
  },
  {
    name: "Message",
    embedded: false
  },
  {
    name: "Content",
    embedded: false
  },
  {
    name: "Text",
    embedded: false
  },
  {
    name: "Image",
    embedded: false
  },
  {
    name: "Voice",
    embedded: false
  },
  {
    name: "Video",
    embedded: false
  },
  {
    name: "File",
    embedded: false
  },
  {
    name: "App",
    embedded: false
  },
  {
    name: "FileGroup",
    embedded: false
  },
  {
    name: "FileIndex",
    embedded: false
  },
  {
    name: "Url",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
