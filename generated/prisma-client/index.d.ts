// Code generated by Prisma (prisma@1.32.0-beta). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  app: (where?: AppWhereInput) => Promise<boolean>;
  avatar: (where?: AvatarWhereInput) => Promise<boolean>;
  chatRoom: (where?: ChatRoomWhereInput) => Promise<boolean>;
  contact: (where?: ContactWhereInput) => Promise<boolean>;
  content: (where?: ContentWhereInput) => Promise<boolean>;
  file: (where?: FileWhereInput) => Promise<boolean>;
  fileIndex: (where?: FileIndexWhereInput) => Promise<boolean>;
  image: (where?: ImageWhereInput) => Promise<boolean>;
  message: (where?: MessageWhereInput) => Promise<boolean>;
  text: (where?: TextWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  video: (where?: VideoWhereInput) => Promise<boolean>;
  voice: (where?: VoiceWhereInput) => Promise<boolean>;
  weChat: (where?: WeChatWhereInput) => Promise<boolean>;
  weChatUser: (where?: WeChatUserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  app: (where: AppWhereUniqueInput) => AppPromise;
  apps: (args?: {
    where?: AppWhereInput;
    orderBy?: AppOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<App>;
  appsConnection: (args?: {
    where?: AppWhereInput;
    orderBy?: AppOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AppConnectionPromise;
  avatar: (where: AvatarWhereUniqueInput) => AvatarPromise;
  avatars: (args?: {
    where?: AvatarWhereInput;
    orderBy?: AvatarOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Avatar>;
  avatarsConnection: (args?: {
    where?: AvatarWhereInput;
    orderBy?: AvatarOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AvatarConnectionPromise;
  chatRoom: (where: ChatRoomWhereUniqueInput) => ChatRoomPromise;
  chatRooms: (args?: {
    where?: ChatRoomWhereInput;
    orderBy?: ChatRoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ChatRoom>;
  chatRoomsConnection: (args?: {
    where?: ChatRoomWhereInput;
    orderBy?: ChatRoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ChatRoomConnectionPromise;
  contact: (where: ContactWhereUniqueInput) => ContactPromise;
  contacts: (args?: {
    where?: ContactWhereInput;
    orderBy?: ContactOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Contact>;
  contactsConnection: (args?: {
    where?: ContactWhereInput;
    orderBy?: ContactOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ContactConnectionPromise;
  content: (where: ContentWhereUniqueInput) => ContentPromise;
  contents: (args?: {
    where?: ContentWhereInput;
    orderBy?: ContentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Content>;
  contentsConnection: (args?: {
    where?: ContentWhereInput;
    orderBy?: ContentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ContentConnectionPromise;
  file: (where: FileWhereUniqueInput) => FilePromise;
  files: (args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<File>;
  filesConnection: (args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FileConnectionPromise;
  fileIndex: (where: FileIndexWhereUniqueInput) => FileIndexPromise;
  fileIndexes: (args?: {
    where?: FileIndexWhereInput;
    orderBy?: FileIndexOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<FileIndex>;
  fileIndexesConnection: (args?: {
    where?: FileIndexWhereInput;
    orderBy?: FileIndexOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FileIndexConnectionPromise;
  image: (where: ImageWhereUniqueInput) => ImagePromise;
  images: (args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Image>;
  imagesConnection: (args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ImageConnectionPromise;
  message: (where: MessageWhereUniqueInput) => MessagePromise;
  messages: (args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Message>;
  messagesConnection: (args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MessageConnectionPromise;
  text: (where: TextWhereUniqueInput) => TextPromise;
  texts: (args?: {
    where?: TextWhereInput;
    orderBy?: TextOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Text>;
  textsConnection: (args?: {
    where?: TextWhereInput;
    orderBy?: TextOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TextConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  video: (where: VideoWhereUniqueInput) => VideoPromise;
  videos: (args?: {
    where?: VideoWhereInput;
    orderBy?: VideoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Video>;
  videosConnection: (args?: {
    where?: VideoWhereInput;
    orderBy?: VideoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => VideoConnectionPromise;
  voice: (where: VoiceWhereUniqueInput) => VoicePromise;
  voices: (args?: {
    where?: VoiceWhereInput;
    orderBy?: VoiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Voice>;
  voicesConnection: (args?: {
    where?: VoiceWhereInput;
    orderBy?: VoiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => VoiceConnectionPromise;
  weChat: (where: WeChatWhereUniqueInput) => WeChatPromise;
  weChats: (args?: {
    where?: WeChatWhereInput;
    orderBy?: WeChatOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<WeChat>;
  weChatsConnection: (args?: {
    where?: WeChatWhereInput;
    orderBy?: WeChatOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => WeChatConnectionPromise;
  weChatUser: (where: WeChatUserWhereUniqueInput) => WeChatUserPromise;
  weChatUsers: (args?: {
    where?: WeChatUserWhereInput;
    orderBy?: WeChatUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<WeChatUser>;
  weChatUsersConnection: (args?: {
    where?: WeChatUserWhereInput;
    orderBy?: WeChatUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => WeChatUserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createApp: (data: AppCreateInput) => AppPromise;
  updateApp: (args: {
    data: AppUpdateInput;
    where: AppWhereUniqueInput;
  }) => AppPromise;
  updateManyApps: (args: {
    data: AppUpdateManyMutationInput;
    where?: AppWhereInput;
  }) => BatchPayloadPromise;
  upsertApp: (args: {
    where: AppWhereUniqueInput;
    create: AppCreateInput;
    update: AppUpdateInput;
  }) => AppPromise;
  deleteApp: (where: AppWhereUniqueInput) => AppPromise;
  deleteManyApps: (where?: AppWhereInput) => BatchPayloadPromise;
  createAvatar: (data: AvatarCreateInput) => AvatarPromise;
  updateAvatar: (args: {
    data: AvatarUpdateInput;
    where: AvatarWhereUniqueInput;
  }) => AvatarPromise;
  upsertAvatar: (args: {
    where: AvatarWhereUniqueInput;
    create: AvatarCreateInput;
    update: AvatarUpdateInput;
  }) => AvatarPromise;
  deleteAvatar: (where: AvatarWhereUniqueInput) => AvatarPromise;
  deleteManyAvatars: (where?: AvatarWhereInput) => BatchPayloadPromise;
  createChatRoom: (data: ChatRoomCreateInput) => ChatRoomPromise;
  updateChatRoom: (args: {
    data: ChatRoomUpdateInput;
    where: ChatRoomWhereUniqueInput;
  }) => ChatRoomPromise;
  updateManyChatRooms: (args: {
    data: ChatRoomUpdateManyMutationInput;
    where?: ChatRoomWhereInput;
  }) => BatchPayloadPromise;
  upsertChatRoom: (args: {
    where: ChatRoomWhereUniqueInput;
    create: ChatRoomCreateInput;
    update: ChatRoomUpdateInput;
  }) => ChatRoomPromise;
  deleteChatRoom: (where: ChatRoomWhereUniqueInput) => ChatRoomPromise;
  deleteManyChatRooms: (where?: ChatRoomWhereInput) => BatchPayloadPromise;
  createContact: (data: ContactCreateInput) => ContactPromise;
  updateContact: (args: {
    data: ContactUpdateInput;
    where: ContactWhereUniqueInput;
  }) => ContactPromise;
  updateManyContacts: (args: {
    data: ContactUpdateManyMutationInput;
    where?: ContactWhereInput;
  }) => BatchPayloadPromise;
  upsertContact: (args: {
    where: ContactWhereUniqueInput;
    create: ContactCreateInput;
    update: ContactUpdateInput;
  }) => ContactPromise;
  deleteContact: (where: ContactWhereUniqueInput) => ContactPromise;
  deleteManyContacts: (where?: ContactWhereInput) => BatchPayloadPromise;
  createContent: (data: ContentCreateInput) => ContentPromise;
  updateContent: (args: {
    data: ContentUpdateInput;
    where: ContentWhereUniqueInput;
  }) => ContentPromise;
  upsertContent: (args: {
    where: ContentWhereUniqueInput;
    create: ContentCreateInput;
    update: ContentUpdateInput;
  }) => ContentPromise;
  deleteContent: (where: ContentWhereUniqueInput) => ContentPromise;
  deleteManyContents: (where?: ContentWhereInput) => BatchPayloadPromise;
  createFile: (data: FileCreateInput) => FilePromise;
  updateFile: (args: {
    data: FileUpdateInput;
    where: FileWhereUniqueInput;
  }) => FilePromise;
  updateManyFiles: (args: {
    data: FileUpdateManyMutationInput;
    where?: FileWhereInput;
  }) => BatchPayloadPromise;
  upsertFile: (args: {
    where: FileWhereUniqueInput;
    create: FileCreateInput;
    update: FileUpdateInput;
  }) => FilePromise;
  deleteFile: (where: FileWhereUniqueInput) => FilePromise;
  deleteManyFiles: (where?: FileWhereInput) => BatchPayloadPromise;
  createFileIndex: (data: FileIndexCreateInput) => FileIndexPromise;
  updateFileIndex: (args: {
    data: FileIndexUpdateInput;
    where: FileIndexWhereUniqueInput;
  }) => FileIndexPromise;
  updateManyFileIndexes: (args: {
    data: FileIndexUpdateManyMutationInput;
    where?: FileIndexWhereInput;
  }) => BatchPayloadPromise;
  upsertFileIndex: (args: {
    where: FileIndexWhereUniqueInput;
    create: FileIndexCreateInput;
    update: FileIndexUpdateInput;
  }) => FileIndexPromise;
  deleteFileIndex: (where: FileIndexWhereUniqueInput) => FileIndexPromise;
  deleteManyFileIndexes: (where?: FileIndexWhereInput) => BatchPayloadPromise;
  createImage: (data: ImageCreateInput) => ImagePromise;
  updateImage: (args: {
    data: ImageUpdateInput;
    where: ImageWhereUniqueInput;
  }) => ImagePromise;
  upsertImage: (args: {
    where: ImageWhereUniqueInput;
    create: ImageCreateInput;
    update: ImageUpdateInput;
  }) => ImagePromise;
  deleteImage: (where: ImageWhereUniqueInput) => ImagePromise;
  deleteManyImages: (where?: ImageWhereInput) => BatchPayloadPromise;
  createMessage: (data: MessageCreateInput) => MessagePromise;
  updateMessage: (args: {
    data: MessageUpdateInput;
    where: MessageWhereUniqueInput;
  }) => MessagePromise;
  updateManyMessages: (args: {
    data: MessageUpdateManyMutationInput;
    where?: MessageWhereInput;
  }) => BatchPayloadPromise;
  upsertMessage: (args: {
    where: MessageWhereUniqueInput;
    create: MessageCreateInput;
    update: MessageUpdateInput;
  }) => MessagePromise;
  deleteMessage: (where: MessageWhereUniqueInput) => MessagePromise;
  deleteManyMessages: (where?: MessageWhereInput) => BatchPayloadPromise;
  createText: (data: TextCreateInput) => TextPromise;
  updateText: (args: {
    data: TextUpdateInput;
    where: TextWhereUniqueInput;
  }) => TextPromise;
  updateManyTexts: (args: {
    data: TextUpdateManyMutationInput;
    where?: TextWhereInput;
  }) => BatchPayloadPromise;
  upsertText: (args: {
    where: TextWhereUniqueInput;
    create: TextCreateInput;
    update: TextUpdateInput;
  }) => TextPromise;
  deleteText: (where: TextWhereUniqueInput) => TextPromise;
  deleteManyTexts: (where?: TextWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createVideo: (data: VideoCreateInput) => VideoPromise;
  updateVideo: (args: {
    data: VideoUpdateInput;
    where: VideoWhereUniqueInput;
  }) => VideoPromise;
  updateManyVideos: (args: {
    data: VideoUpdateManyMutationInput;
    where?: VideoWhereInput;
  }) => BatchPayloadPromise;
  upsertVideo: (args: {
    where: VideoWhereUniqueInput;
    create: VideoCreateInput;
    update: VideoUpdateInput;
  }) => VideoPromise;
  deleteVideo: (where: VideoWhereUniqueInput) => VideoPromise;
  deleteManyVideos: (where?: VideoWhereInput) => BatchPayloadPromise;
  createVoice: (data: VoiceCreateInput) => VoicePromise;
  updateVoice: (args: {
    data: VoiceUpdateInput;
    where: VoiceWhereUniqueInput;
  }) => VoicePromise;
  updateManyVoices: (args: {
    data: VoiceUpdateManyMutationInput;
    where?: VoiceWhereInput;
  }) => BatchPayloadPromise;
  upsertVoice: (args: {
    where: VoiceWhereUniqueInput;
    create: VoiceCreateInput;
    update: VoiceUpdateInput;
  }) => VoicePromise;
  deleteVoice: (where: VoiceWhereUniqueInput) => VoicePromise;
  deleteManyVoices: (where?: VoiceWhereInput) => BatchPayloadPromise;
  createWeChat: (data: WeChatCreateInput) => WeChatPromise;
  updateWeChat: (args: {
    data: WeChatUpdateInput;
    where: WeChatWhereUniqueInput;
  }) => WeChatPromise;
  upsertWeChat: (args: {
    where: WeChatWhereUniqueInput;
    create: WeChatCreateInput;
    update: WeChatUpdateInput;
  }) => WeChatPromise;
  deleteWeChat: (where: WeChatWhereUniqueInput) => WeChatPromise;
  deleteManyWeChats: (where?: WeChatWhereInput) => BatchPayloadPromise;
  createWeChatUser: (data: WeChatUserCreateInput) => WeChatUserPromise;
  updateWeChatUser: (args: {
    data: WeChatUserUpdateInput;
    where: WeChatUserWhereUniqueInput;
  }) => WeChatUserPromise;
  updateManyWeChatUsers: (args: {
    data: WeChatUserUpdateManyMutationInput;
    where?: WeChatUserWhereInput;
  }) => BatchPayloadPromise;
  upsertWeChatUser: (args: {
    where: WeChatUserWhereUniqueInput;
    create: WeChatUserCreateInput;
    update: WeChatUserUpdateInput;
  }) => WeChatUserPromise;
  deleteWeChatUser: (where: WeChatUserWhereUniqueInput) => WeChatUserPromise;
  deleteManyWeChatUsers: (where?: WeChatUserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  app: (
    where?: AppSubscriptionWhereInput
  ) => AppSubscriptionPayloadSubscription;
  avatar: (
    where?: AvatarSubscriptionWhereInput
  ) => AvatarSubscriptionPayloadSubscription;
  chatRoom: (
    where?: ChatRoomSubscriptionWhereInput
  ) => ChatRoomSubscriptionPayloadSubscription;
  contact: (
    where?: ContactSubscriptionWhereInput
  ) => ContactSubscriptionPayloadSubscription;
  content: (
    where?: ContentSubscriptionWhereInput
  ) => ContentSubscriptionPayloadSubscription;
  file: (
    where?: FileSubscriptionWhereInput
  ) => FileSubscriptionPayloadSubscription;
  fileIndex: (
    where?: FileIndexSubscriptionWhereInput
  ) => FileIndexSubscriptionPayloadSubscription;
  image: (
    where?: ImageSubscriptionWhereInput
  ) => ImageSubscriptionPayloadSubscription;
  message: (
    where?: MessageSubscriptionWhereInput
  ) => MessageSubscriptionPayloadSubscription;
  text: (
    where?: TextSubscriptionWhereInput
  ) => TextSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  video: (
    where?: VideoSubscriptionWhereInput
  ) => VideoSubscriptionPayloadSubscription;
  voice: (
    where?: VoiceSubscriptionWhereInput
  ) => VoiceSubscriptionPayloadSubscription;
  weChat: (
    where?: WeChatSubscriptionWhereInput
  ) => WeChatSubscriptionPayloadSubscription;
  weChatUser: (
    where?: WeChatUserSubscriptionWhereInput
  ) => WeChatUserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type FileIndexOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "fileName_ASC"
  | "fileName_DESC"
  | "mimetype_ASC"
  | "mimetype_DESC"
  | "size_ASC"
  | "size_DESC"
  | "url_ASC"
  | "url_DESC";

export type AppOrderByInput = "id_ASC" | "id_DESC" | "xml_ASC" | "xml_DESC";

export type FileOrderByInput = "id_ASC" | "id_DESC" | "size_ASC" | "size_DESC";

export type VoiceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "voiceLength_ASC"
  | "voiceLength_DESC";

export type ContentOrderByInput = "id_ASC" | "id_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "name_ASC"
  | "name_DESC"
  | "password_ASC"
  | "password_DESC";

export type ContactOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC";

export type TextOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "textMsg_ASC"
  | "textMsg_DESC";

export type AvatarOrderByInput = "id_ASC" | "id_DESC";

export type MessageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "msgSvrId_ASC"
  | "msgSvrId_DESC"
  | "isSend_ASC"
  | "isSend_DESC"
  | "type_ASC"
  | "type_DESC"
  | "createTime_ASC"
  | "createTime_DESC";

export type ChatRoomOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "username_ASC"
  | "username_DESC"
  | "nickname_ASC"
  | "nickname_DESC"
  | "displayName_ASC"
  | "displayName_DESC"
  | "modifyTime_ASC"
  | "modifyTime_DESC";

export type WeChatUserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "username_ASC"
  | "username_DESC"
  | "alias_ASC"
  | "alias_DESC"
  | "conRemark_ASC"
  | "conRemark_DESC"
  | "nickname_ASC"
  | "nickname_DESC";

export type ImageOrderByInput = "id_ASC" | "id_DESC";

export type WeChatOrderByInput = "id_ASC" | "id_DESC";

export type VideoOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "videolength_ASC"
  | "videolength_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface WeChatUserUpdateWithoutHaveChatRoomDataInput {
  username?: String;
  alias?: String;
  conRemark?: String;
  nickname?: String;
  avatar?: AvatarUpdateOneInput;
  message?: MessageUpdateManyWithoutTalkerInput;
  joinChatRoom?: ChatRoomUpdateManyWithoutMemberListInput;
  contact?: ContactUpdateOneWithoutWeChatUserInput;
}

export type AppWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface WeChatUserUpdateManyWithoutJoinChatRoomInput {
  create?:
    | WeChatUserCreateWithoutJoinChatRoomInput[]
    | WeChatUserCreateWithoutJoinChatRoomInput;
  delete?: WeChatUserWhereUniqueInput[] | WeChatUserWhereUniqueInput;
  connect?: WeChatUserWhereUniqueInput[] | WeChatUserWhereUniqueInput;
  set?: WeChatUserWhereUniqueInput[] | WeChatUserWhereUniqueInput;
  disconnect?: WeChatUserWhereUniqueInput[] | WeChatUserWhereUniqueInput;
  update?:
    | WeChatUserUpdateWithWhereUniqueWithoutJoinChatRoomInput[]
    | WeChatUserUpdateWithWhereUniqueWithoutJoinChatRoomInput;
  upsert?:
    | WeChatUserUpsertWithWhereUniqueWithoutJoinChatRoomInput[]
    | WeChatUserUpsertWithWhereUniqueWithoutJoinChatRoomInput;
  deleteMany?: WeChatUserScalarWhereInput[] | WeChatUserScalarWhereInput;
  updateMany?:
    | WeChatUserUpdateManyWithWhereNestedInput[]
    | WeChatUserUpdateManyWithWhereNestedInput;
}

export interface VoiceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  fileName?: FileIndexWhereInput;
  voiceLength?: Int;
  voiceLength_not?: Int;
  voiceLength_in?: Int[] | Int;
  voiceLength_not_in?: Int[] | Int;
  voiceLength_lt?: Int;
  voiceLength_lte?: Int;
  voiceLength_gt?: Int;
  voiceLength_gte?: Int;
  content?: ContentWhereInput;
  AND?: VoiceWhereInput[] | VoiceWhereInput;
}

export interface WeChatUserUpdateWithWhereUniqueWithoutJoinChatRoomInput {
  where: WeChatUserWhereUniqueInput;
  data: WeChatUserUpdateWithoutJoinChatRoomDataInput;
}

export interface FileWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  fileName?: FileIndexWhereInput;
  size?: Int;
  size_not?: Int;
  size_in?: Int[] | Int;
  size_not_in?: Int[] | Int;
  size_lt?: Int;
  size_lte?: Int;
  size_gt?: Int;
  size_gte?: Int;
  content?: ContentWhereInput;
  AND?: FileWhereInput[] | FileWhereInput;
}

export interface VideoUpdateWithoutContentDataInput {
  fileName?: FileIndexUpdateOneInput;
  thumbnailImg?: FileIndexUpdateOneInput;
  videolength?: Int;
}

export interface TextUpdateInput {
  textMsg?: String;
  content?: ContentUpdateOneWithoutTextInput;
}

export interface VideoUpsertWithoutContentInput {
  update: VideoUpdateWithoutContentDataInput;
  create: VideoCreateWithoutContentInput;
}

export interface WeChatUserUpdateWithoutJoinChatRoomDataInput {
  username?: String;
  alias?: String;
  conRemark?: String;
  nickname?: String;
  avatar?: AvatarUpdateOneInput;
  message?: MessageUpdateManyWithoutTalkerInput;
  haveChatRoom?: ChatRoomUpdateManyWithoutOwnerInput;
  contact?: ContactUpdateOneWithoutWeChatUserInput;
}

export interface FileUpdateOneWithoutContentInput {
  create?: FileCreateWithoutContentInput;
  update?: FileUpdateWithoutContentDataInput;
  upsert?: FileUpsertWithoutContentInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: FileWhereUniqueInput;
}

export interface WeChatSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: WeChatWhereInput;
  AND?: WeChatSubscriptionWhereInput[] | WeChatSubscriptionWhereInput;
}

export interface FileUpdateWithoutContentDataInput {
  fileName?: FileIndexUpdateOneInput;
  size?: Int;
}

export type AvatarWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface FileUpsertWithoutContentInput {
  update: FileUpdateWithoutContentDataInput;
  create: FileCreateWithoutContentInput;
}

export interface AvatarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  thumbnailImg?: FileIndexWhereInput;
  bigImg?: FileIndexWhereInput;
  AND?: AvatarWhereInput[] | AvatarWhereInput;
}

export interface ContentUpsertWithoutAppInput {
  update: ContentUpdateWithoutAppDataInput;
  create: ContentCreateWithoutAppInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface AppUpdateManyMutationInput {
  xml?: Json;
}

export interface MessageSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: MessageWhereInput;
  AND?: MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput;
}

export interface TextUpdateManyMutationInput {
  textMsg?: String;
}

export interface ImageSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ImageWhereInput;
  AND?: ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput;
}

export interface ContentUpsertWithoutTextInput {
  update: ContentUpdateWithoutTextDataInput;
  create: ContentCreateWithoutTextInput;
}

export interface MessageWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  msgSvrId?: String;
  msgSvrId_not?: String;
  msgSvrId_in?: String[] | String;
  msgSvrId_not_in?: String[] | String;
  msgSvrId_lt?: String;
  msgSvrId_lte?: String;
  msgSvrId_gt?: String;
  msgSvrId_gte?: String;
  msgSvrId_contains?: String;
  msgSvrId_not_contains?: String;
  msgSvrId_starts_with?: String;
  msgSvrId_not_starts_with?: String;
  msgSvrId_ends_with?: String;
  msgSvrId_not_ends_with?: String;
  isSend?: Int;
  isSend_not?: Int;
  isSend_in?: Int[] | Int;
  isSend_not_in?: Int[] | Int;
  isSend_lt?: Int;
  isSend_lte?: Int;
  isSend_gt?: Int;
  isSend_gte?: Int;
  type?: Int;
  type_not?: Int;
  type_in?: Int[] | Int;
  type_not_in?: Int[] | Int;
  type_lt?: Int;
  type_lte?: Int;
  type_gt?: Int;
  type_gte?: Int;
  talker?: WeChatUserWhereInput;
  createTime?: DateTimeInput;
  createTime_not?: DateTimeInput;
  createTime_in?: DateTimeInput[] | DateTimeInput;
  createTime_not_in?: DateTimeInput[] | DateTimeInput;
  createTime_lt?: DateTimeInput;
  createTime_lte?: DateTimeInput;
  createTime_gt?: DateTimeInput;
  createTime_gte?: DateTimeInput;
  chatRoom?: ChatRoomWhereInput;
  content?: ContentWhereInput;
  AND?: MessageWhereInput[] | MessageWhereInput;
}

export interface AvatarCreateInput {
  id?: ID_Input;
  thumbnailImg?: FileIndexCreateOneInput;
  bigImg?: FileIndexCreateOneInput;
}

export interface ChatRoomWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  nickname?: String;
  nickname_not?: String;
  nickname_in?: String[] | String;
  nickname_not_in?: String[] | String;
  nickname_lt?: String;
  nickname_lte?: String;
  nickname_gt?: String;
  nickname_gte?: String;
  nickname_contains?: String;
  nickname_not_contains?: String;
  nickname_starts_with?: String;
  nickname_not_starts_with?: String;
  nickname_ends_with?: String;
  nickname_not_ends_with?: String;
  displayName?: String;
  displayName_not?: String;
  displayName_in?: String[] | String;
  displayName_not_in?: String[] | String;
  displayName_lt?: String;
  displayName_lte?: String;
  displayName_gt?: String;
  displayName_gte?: String;
  displayName_contains?: String;
  displayName_not_contains?: String;
  displayName_starts_with?: String;
  displayName_not_starts_with?: String;
  displayName_ends_with?: String;
  displayName_not_ends_with?: String;
  owner?: WeChatUserWhereInput;
  memberList_some?: WeChatUserWhereInput;
  modifyTime?: DateTimeInput;
  modifyTime_not?: DateTimeInput;
  modifyTime_in?: DateTimeInput[] | DateTimeInput;
  modifyTime_not_in?: DateTimeInput[] | DateTimeInput;
  modifyTime_lt?: DateTimeInput;
  modifyTime_lte?: DateTimeInput;
  modifyTime_gt?: DateTimeInput;
  modifyTime_gte?: DateTimeInput;
  avatar?: AvatarWhereInput;
  message_some?: MessageWhereInput;
  AND?: ChatRoomWhereInput[] | ChatRoomWhereInput;
}

export interface AvatarUpdateInput {
  thumbnailImg?: FileIndexUpdateOneInput;
  bigImg?: FileIndexUpdateOneInput;
}

export interface ContactWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  type?: String;
  type_not?: String;
  type_in?: String[] | String;
  type_not_in?: String[] | String;
  type_lt?: String;
  type_lte?: String;
  type_gt?: String;
  type_gte?: String;
  type_contains?: String;
  type_not_contains?: String;
  type_starts_with?: String;
  type_not_starts_with?: String;
  type_ends_with?: String;
  type_not_ends_with?: String;
  weChatUser_some?: WeChatUserWhereInput;
  AND?: ContactWhereInput[] | ContactWhereInput;
}

export interface ChatRoomCreateInput {
  id?: ID_Input;
  username: String;
  nickname?: String;
  displayName: String;
  owner?: WeChatUserCreateOneWithoutHaveChatRoomInput;
  memberList?: WeChatUserCreateManyWithoutJoinChatRoomInput;
  modifyTime?: DateTimeInput;
  avatar?: AvatarCreateOneInput;
  message?: MessageCreateManyWithoutChatRoomInput;
}

export interface ContentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ContentWhereInput;
  AND?: ContentSubscriptionWhereInput[] | ContentSubscriptionWhereInput;
}

export interface WeChatUserCreateOneWithoutHaveChatRoomInput {
  create?: WeChatUserCreateWithoutHaveChatRoomInput;
  connect?: WeChatUserWhereUniqueInput;
}

export interface ContactSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ContactWhereInput;
  AND?: ContactSubscriptionWhereInput[] | ContactSubscriptionWhereInput;
}

export interface WeChatUserCreateWithoutHaveChatRoomInput {
  id?: ID_Input;
  username: String;
  alias?: String;
  conRemark?: String;
  nickname?: String;
  avatar?: AvatarCreateOneInput;
  message?: MessageCreateManyWithoutTalkerInput;
  joinChatRoom?: ChatRoomCreateManyWithoutMemberListInput;
  contact?: ContactCreateOneWithoutWeChatUserInput;
}

export interface ChatRoomSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ChatRoomWhereInput;
  AND?: ChatRoomSubscriptionWhereInput[] | ChatRoomSubscriptionWhereInput;
}

export interface AvatarCreateOneInput {
  create?: AvatarCreateInput;
  connect?: AvatarWhereUniqueInput;
}

export interface AppSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AppWhereInput;
  AND?: AppSubscriptionWhereInput[] | AppSubscriptionWhereInput;
}

export interface MessageCreateManyWithoutTalkerInput {
  create?: MessageCreateWithoutTalkerInput[] | MessageCreateWithoutTalkerInput;
  connect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
}

export interface WeChatUserUpdateManyMutationInput {
  username?: String;
  alias?: String;
  conRemark?: String;
  nickname?: String;
}

export interface MessageCreateWithoutTalkerInput {
  id?: ID_Input;
  msgSvrId?: String;
  isSend?: Int;
  type?: Int;
  createTime?: DateTimeInput;
  chatRoom?: ChatRoomCreateOneWithoutMessageInput;
  content?: ContentCreateOneInput;
}

export interface WeChatUpdateInput {
  weChatOwner?: WeChatUserUpdateOneRequiredInput;
  weChatUsers?: WeChatUserUpdateManyInput;
  chatRooms?: ChatRoomUpdateManyInput;
  messages?: MessageUpdateManyInput;
}

export interface ChatRoomCreateOneWithoutMessageInput {
  create?: ChatRoomCreateWithoutMessageInput;
  connect?: ChatRoomWhereUniqueInput;
}

export type ContentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ChatRoomCreateWithoutMessageInput {
  id?: ID_Input;
  username: String;
  nickname?: String;
  displayName: String;
  owner?: WeChatUserCreateOneWithoutHaveChatRoomInput;
  memberList?: WeChatUserCreateManyWithoutJoinChatRoomInput;
  modifyTime?: DateTimeInput;
  avatar?: AvatarCreateOneInput;
}

export interface ContentUpdateWithoutVoiceDataInput {
  text?: TextUpdateOneWithoutContentInput;
  image?: ImageUpdateOneWithoutContentInput;
  video?: VideoUpdateOneWithoutContentInput;
  file?: FileUpdateOneWithoutContentInput;
  app?: AppUpdateOneWithoutContentInput;
}

export interface WeChatUserCreateManyWithoutJoinChatRoomInput {
  create?:
    | WeChatUserCreateWithoutJoinChatRoomInput[]
    | WeChatUserCreateWithoutJoinChatRoomInput;
  connect?: WeChatUserWhereUniqueInput[] | WeChatUserWhereUniqueInput;
}

export interface VoiceUpdateInput {
  fileName?: FileIndexUpdateOneInput;
  voiceLength?: Int;
  content?: ContentUpdateOneWithoutVoiceInput;
}

export interface WeChatUserCreateWithoutJoinChatRoomInput {
  id?: ID_Input;
  username: String;
  alias?: String;
  conRemark?: String;
  nickname?: String;
  avatar?: AvatarCreateOneInput;
  message?: MessageCreateManyWithoutTalkerInput;
  haveChatRoom?: ChatRoomCreateManyWithoutOwnerInput;
  contact?: ContactCreateOneWithoutWeChatUserInput;
}

export interface ContentCreateWithoutVoiceInput {
  id?: ID_Input;
  text?: TextCreateOneWithoutContentInput;
  image?: ImageCreateOneWithoutContentInput;
  video?: VideoCreateOneWithoutContentInput;
  file?: FileCreateOneWithoutContentInput;
  app?: AppCreateOneWithoutContentInput;
}

export interface ChatRoomCreateManyWithoutOwnerInput {
  create?: ChatRoomCreateWithoutOwnerInput[] | ChatRoomCreateWithoutOwnerInput;
  connect?: ChatRoomWhereUniqueInput[] | ChatRoomWhereUniqueInput;
}

export interface VoiceCreateInput {
  id?: ID_Input;
  fileName?: FileIndexCreateOneInput;
  voiceLength?: Int;
  content?: ContentCreateOneWithoutVoiceInput;
}

export interface ChatRoomCreateWithoutOwnerInput {
  id?: ID_Input;
  username: String;
  nickname?: String;
  displayName: String;
  memberList?: WeChatUserCreateManyWithoutJoinChatRoomInput;
  modifyTime?: DateTimeInput;
  avatar?: AvatarCreateOneInput;
  message?: MessageCreateManyWithoutChatRoomInput;
}

export type FileIndexWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  fileName?: String;
}>;

export interface MessageCreateManyWithoutChatRoomInput {
  create?:
    | MessageCreateWithoutChatRoomInput[]
    | MessageCreateWithoutChatRoomInput;
  connect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
}

export interface ContentUpdateWithoutVideoDataInput {
  text?: TextUpdateOneWithoutContentInput;
  image?: ImageUpdateOneWithoutContentInput;
  voice?: VoiceUpdateOneWithoutContentInput;
  file?: FileUpdateOneWithoutContentInput;
  app?: AppUpdateOneWithoutContentInput;
}

export interface MessageCreateWithoutChatRoomInput {
  id?: ID_Input;
  msgSvrId?: String;
  isSend?: Int;
  type?: Int;
  talker: WeChatUserCreateOneWithoutMessageInput;
  createTime?: DateTimeInput;
  content?: ContentCreateOneInput;
}

export interface VideoUpdateInput {
  fileName?: FileIndexUpdateOneInput;
  thumbnailImg?: FileIndexUpdateOneInput;
  videolength?: Int;
  content?: ContentUpdateOneWithoutVideoInput;
}

export interface WeChatUserCreateOneWithoutMessageInput {
  create?: WeChatUserCreateWithoutMessageInput;
  connect?: WeChatUserWhereUniqueInput;
}

export interface ContentCreateWithoutVideoInput {
  id?: ID_Input;
  text?: TextCreateOneWithoutContentInput;
  image?: ImageCreateOneWithoutContentInput;
  voice?: VoiceCreateOneWithoutContentInput;
  file?: FileCreateOneWithoutContentInput;
  app?: AppCreateOneWithoutContentInput;
}

export interface WeChatUserCreateWithoutMessageInput {
  id?: ID_Input;
  username: String;
  alias?: String;
  conRemark?: String;
  nickname?: String;
  avatar?: AvatarCreateOneInput;
  haveChatRoom?: ChatRoomCreateManyWithoutOwnerInput;
  joinChatRoom?: ChatRoomCreateManyWithoutMemberListInput;
  contact?: ContactCreateOneWithoutWeChatUserInput;
}

export interface VideoCreateInput {
  id?: ID_Input;
  fileName?: FileIndexCreateOneInput;
  thumbnailImg?: FileIndexCreateOneInput;
  videolength?: Int;
  content?: ContentCreateOneWithoutVideoInput;
}

export interface ChatRoomCreateManyWithoutMemberListInput {
  create?:
    | ChatRoomCreateWithoutMemberListInput[]
    | ChatRoomCreateWithoutMemberListInput;
  connect?: ChatRoomWhereUniqueInput[] | ChatRoomWhereUniqueInput;
}

export type MessageWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ChatRoomCreateWithoutMemberListInput {
  id?: ID_Input;
  username: String;
  nickname?: String;
  displayName: String;
  owner?: WeChatUserCreateOneWithoutHaveChatRoomInput;
  modifyTime?: DateTimeInput;
  avatar?: AvatarCreateOneInput;
  message?: MessageCreateManyWithoutChatRoomInput;
}

export interface WeChatUpsertWithWhereUniqueNestedInput {
  where: WeChatWhereUniqueInput;
  update: WeChatUpdateDataInput;
  create: WeChatCreateInput;
}

export interface ContactCreateOneWithoutWeChatUserInput {
  create?: ContactCreateWithoutWeChatUserInput;
  connect?: ContactWhereUniqueInput;
}

export type TextWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ContactCreateWithoutWeChatUserInput {
  id?: ID_Input;
  type: String;
}

export interface MessageUpdateWithWhereUniqueNestedInput {
  where: MessageWhereUniqueInput;
  data: MessageUpdateDataInput;
}

export interface ContentCreateOneInput {
  create?: ContentCreateInput;
  connect?: ContentWhereUniqueInput;
}

export interface ChatRoomUpsertWithWhereUniqueNestedInput {
  where: ChatRoomWhereUniqueInput;
  update: ChatRoomUpdateDataInput;
  create: ChatRoomCreateInput;
}

export interface ContentCreateInput {
  id?: ID_Input;
  text?: TextCreateOneWithoutContentInput;
  image?: ImageCreateOneWithoutContentInput;
  voice?: VoiceCreateOneWithoutContentInput;
  video?: VideoCreateOneWithoutContentInput;
  file?: FileCreateOneWithoutContentInput;
  app?: AppCreateOneWithoutContentInput;
}

export interface ChatRoomUpdateDataInput {
  username?: String;
  nickname?: String;
  displayName?: String;
  owner?: WeChatUserUpdateOneWithoutHaveChatRoomInput;
  memberList?: WeChatUserUpdateManyWithoutJoinChatRoomInput;
  modifyTime?: DateTimeInput;
  avatar?: AvatarUpdateOneInput;
  message?: MessageUpdateManyWithoutChatRoomInput;
}

export interface AppCreateOneWithoutContentInput {
  create?: AppCreateWithoutContentInput;
  connect?: AppWhereUniqueInput;
}

export interface ChatRoomUpdateWithWhereUniqueNestedInput {
  where: ChatRoomWhereUniqueInput;
  data: ChatRoomUpdateDataInput;
}

export interface AppCreateWithoutContentInput {
  id?: ID_Input;
  xml?: Json;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  weChat_some?: WeChatWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
}

export interface ChatRoomUpdateInput {
  username?: String;
  nickname?: String;
  displayName?: String;
  owner?: WeChatUserUpdateOneWithoutHaveChatRoomInput;
  memberList?: WeChatUserUpdateManyWithoutJoinChatRoomInput;
  modifyTime?: DateTimeInput;
  avatar?: AvatarUpdateOneInput;
  message?: MessageUpdateManyWithoutChatRoomInput;
}

export interface WeChatUserUpdateWithWhereUniqueNestedInput {
  where: WeChatUserWhereUniqueInput;
  data: WeChatUserUpdateDataInput;
}

export interface WeChatUserUpdateOneWithoutHaveChatRoomInput {
  create?: WeChatUserCreateWithoutHaveChatRoomInput;
  update?: WeChatUserUpdateWithoutHaveChatRoomDataInput;
  upsert?: WeChatUserUpsertWithoutHaveChatRoomInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: WeChatUserWhereUniqueInput;
}

export interface WeChatUserUpsertNestedInput {
  update: WeChatUserUpdateDataInput;
  create: WeChatUserCreateInput;
}

export interface ContentUpdateWithoutTextDataInput {
  image?: ImageUpdateOneWithoutContentInput;
  voice?: VoiceUpdateOneWithoutContentInput;
  video?: VideoUpdateOneWithoutContentInput;
  file?: FileUpdateOneWithoutContentInput;
  app?: AppUpdateOneWithoutContentInput;
}

export interface WeChatUserUpdateDataInput {
  username?: String;
  alias?: String;
  conRemark?: String;
  nickname?: String;
  avatar?: AvatarUpdateOneInput;
  message?: MessageUpdateManyWithoutTalkerInput;
  haveChatRoom?: ChatRoomUpdateManyWithoutOwnerInput;
  joinChatRoom?: ChatRoomUpdateManyWithoutMemberListInput;
  contact?: ContactUpdateOneWithoutWeChatUserInput;
}

export interface AvatarUpdateOneInput {
  create?: AvatarCreateInput;
  update?: AvatarUpdateDataInput;
  upsert?: AvatarUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: AvatarWhereUniqueInput;
}

export interface WeChatUpdateDataInput {
  weChatOwner?: WeChatUserUpdateOneRequiredInput;
  weChatUsers?: WeChatUserUpdateManyInput;
  chatRooms?: ChatRoomUpdateManyInput;
  messages?: MessageUpdateManyInput;
}

export interface AvatarUpdateDataInput {
  thumbnailImg?: FileIndexUpdateOneInput;
  bigImg?: FileIndexUpdateOneInput;
}

export type VoiceWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AvatarUpsertNestedInput {
  update: AvatarUpdateDataInput;
  create: AvatarCreateInput;
}

export interface UserUpdateInput {
  email?: String;
  name?: String;
  password?: String;
  weChat?: WeChatUpdateManyInput;
}

export interface MessageUpdateManyWithoutTalkerInput {
  create?: MessageCreateWithoutTalkerInput[] | MessageCreateWithoutTalkerInput;
  delete?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  connect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  set?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  disconnect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  update?:
    | MessageUpdateWithWhereUniqueWithoutTalkerInput[]
    | MessageUpdateWithWhereUniqueWithoutTalkerInput;
  upsert?:
    | MessageUpsertWithWhereUniqueWithoutTalkerInput[]
    | MessageUpsertWithWhereUniqueWithoutTalkerInput;
  deleteMany?: MessageScalarWhereInput[] | MessageScalarWhereInput;
  updateMany?:
    | MessageUpdateManyWithWhereNestedInput[]
    | MessageUpdateManyWithWhereNestedInput;
}

export interface ChatRoomCreateManyInput {
  create?: ChatRoomCreateInput[] | ChatRoomCreateInput;
  connect?: ChatRoomWhereUniqueInput[] | ChatRoomWhereUniqueInput;
}

export interface MessageUpdateWithWhereUniqueWithoutTalkerInput {
  where: MessageWhereUniqueInput;
  data: MessageUpdateWithoutTalkerDataInput;
}

export interface WeChatUserCreateManyInput {
  create?: WeChatUserCreateInput[] | WeChatUserCreateInput;
  connect?: WeChatUserWhereUniqueInput[] | WeChatUserWhereUniqueInput;
}

export interface MessageUpdateWithoutTalkerDataInput {
  msgSvrId?: String;
  isSend?: Int;
  type?: Int;
  createTime?: DateTimeInput;
  chatRoom?: ChatRoomUpdateOneWithoutMessageInput;
  content?: ContentUpdateOneInput;
}

export interface WeChatUserCreateOneInput {
  create?: WeChatUserCreateInput;
  connect?: WeChatUserWhereUniqueInput;
}

export interface ChatRoomUpdateOneWithoutMessageInput {
  create?: ChatRoomCreateWithoutMessageInput;
  update?: ChatRoomUpdateWithoutMessageDataInput;
  upsert?: ChatRoomUpsertWithoutMessageInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ChatRoomWhereUniqueInput;
}

export interface WeChatCreateInput {
  id?: ID_Input;
  weChatOwner: WeChatUserCreateOneInput;
  weChatUsers?: WeChatUserCreateManyInput;
  chatRooms?: ChatRoomCreateManyInput;
  messages?: MessageCreateManyInput;
}

export interface ChatRoomUpdateWithoutMessageDataInput {
  username?: String;
  nickname?: String;
  displayName?: String;
  owner?: WeChatUserUpdateOneWithoutHaveChatRoomInput;
  memberList?: WeChatUserUpdateManyWithoutJoinChatRoomInput;
  modifyTime?: DateTimeInput;
  avatar?: AvatarUpdateOneInput;
}

export interface UserCreateInput {
  id?: ID_Input;
  email: String;
  name: String;
  password: String;
  weChat?: WeChatCreateManyInput;
}

export interface VideoWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  fileName?: FileIndexWhereInput;
  thumbnailImg?: FileIndexWhereInput;
  videolength?: Int;
  videolength_not?: Int;
  videolength_in?: Int[] | Int;
  videolength_not_in?: Int[] | Int;
  videolength_lt?: Int;
  videolength_lte?: Int;
  videolength_gt?: Int;
  videolength_gte?: Int;
  content?: ContentWhereInput;
  AND?: VideoWhereInput[] | VideoWhereInput;
}

export interface AppCreateInput {
  id?: ID_Input;
  xml?: Json;
  content?: ContentCreateOneWithoutAppInput;
}

export interface FileIndexWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  fileName?: String;
  fileName_not?: String;
  fileName_in?: String[] | String;
  fileName_not_in?: String[] | String;
  fileName_lt?: String;
  fileName_lte?: String;
  fileName_gt?: String;
  fileName_gte?: String;
  fileName_contains?: String;
  fileName_not_contains?: String;
  fileName_starts_with?: String;
  fileName_not_starts_with?: String;
  fileName_ends_with?: String;
  fileName_not_ends_with?: String;
  mimetype?: String;
  mimetype_not?: String;
  mimetype_in?: String[] | String;
  mimetype_not_in?: String[] | String;
  mimetype_lt?: String;
  mimetype_lte?: String;
  mimetype_gt?: String;
  mimetype_gte?: String;
  mimetype_contains?: String;
  mimetype_not_contains?: String;
  mimetype_starts_with?: String;
  mimetype_not_starts_with?: String;
  mimetype_ends_with?: String;
  mimetype_not_ends_with?: String;
  size?: Int;
  size_not?: Int;
  size_in?: Int[] | Int;
  size_not_in?: Int[] | Int;
  size_lt?: Int;
  size_lte?: Int;
  size_gt?: Int;
  size_gte?: Int;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  AND?: FileIndexWhereInput[] | FileIndexWhereInput;
}

export interface ContentCreateWithoutAppInput {
  id?: ID_Input;
  text?: TextCreateOneWithoutContentInput;
  image?: ImageCreateOneWithoutContentInput;
  voice?: VoiceCreateOneWithoutContentInput;
  video?: VideoCreateOneWithoutContentInput;
  file?: FileCreateOneWithoutContentInput;
}

export interface ContentUpdateOneWithoutTextInput {
  create?: ContentCreateWithoutTextInput;
  update?: ContentUpdateWithoutTextDataInput;
  upsert?: ContentUpsertWithoutTextInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ContentWhereUniqueInput;
}

export interface TextCreateWithoutContentInput {
  id?: ID_Input;
  textMsg: String;
}

export interface ChatRoomUpdateManyWithoutOwnerInput {
  create?: ChatRoomCreateWithoutOwnerInput[] | ChatRoomCreateWithoutOwnerInput;
  delete?: ChatRoomWhereUniqueInput[] | ChatRoomWhereUniqueInput;
  connect?: ChatRoomWhereUniqueInput[] | ChatRoomWhereUniqueInput;
  set?: ChatRoomWhereUniqueInput[] | ChatRoomWhereUniqueInput;
  disconnect?: ChatRoomWhereUniqueInput[] | ChatRoomWhereUniqueInput;
  update?:
    | ChatRoomUpdateWithWhereUniqueWithoutOwnerInput[]
    | ChatRoomUpdateWithWhereUniqueWithoutOwnerInput;
  upsert?:
    | ChatRoomUpsertWithWhereUniqueWithoutOwnerInput[]
    | ChatRoomUpsertWithWhereUniqueWithoutOwnerInput;
  deleteMany?: ChatRoomScalarWhereInput[] | ChatRoomScalarWhereInput;
  updateMany?:
    | ChatRoomUpdateManyWithWhereNestedInput[]
    | ChatRoomUpdateManyWithWhereNestedInput;
}

export interface ImageCreateWithoutContentInput {
  id?: ID_Input;
  thumbnailImg?: FileIndexCreateOneInput;
  bigImg?: FileIndexCreateOneInput;
}

export interface ChatRoomUpdateWithWhereUniqueWithoutOwnerInput {
  where: ChatRoomWhereUniqueInput;
  data: ChatRoomUpdateWithoutOwnerDataInput;
}

export interface FileIndexCreateInput {
  id?: ID_Input;
  fileName: String;
  mimetype: String;
  size: Int;
  url?: String;
}

export interface ChatRoomUpdateWithoutOwnerDataInput {
  username?: String;
  nickname?: String;
  displayName?: String;
  memberList?: WeChatUserUpdateManyWithoutJoinChatRoomInput;
  modifyTime?: DateTimeInput;
  avatar?: AvatarUpdateOneInput;
  message?: MessageUpdateManyWithoutChatRoomInput;
}

export interface VoiceCreateWithoutContentInput {
  id?: ID_Input;
  fileName?: FileIndexCreateOneInput;
  voiceLength?: Int;
}

export interface MessageUpdateManyWithoutChatRoomInput {
  create?:
    | MessageCreateWithoutChatRoomInput[]
    | MessageCreateWithoutChatRoomInput;
  delete?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  connect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  set?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  disconnect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  update?:
    | MessageUpdateWithWhereUniqueWithoutChatRoomInput[]
    | MessageUpdateWithWhereUniqueWithoutChatRoomInput;
  upsert?:
    | MessageUpsertWithWhereUniqueWithoutChatRoomInput[]
    | MessageUpsertWithWhereUniqueWithoutChatRoomInput;
  deleteMany?: MessageScalarWhereInput[] | MessageScalarWhereInput;
  updateMany?:
    | MessageUpdateManyWithWhereNestedInput[]
    | MessageUpdateManyWithWhereNestedInput;
}

export interface VideoCreateWithoutContentInput {
  id?: ID_Input;
  fileName?: FileIndexCreateOneInput;
  thumbnailImg?: FileIndexCreateOneInput;
  videolength?: Int;
}

export interface MessageUpdateWithWhereUniqueWithoutChatRoomInput {
  where: MessageWhereUniqueInput;
  data: MessageUpdateWithoutChatRoomDataInput;
}

export interface FileCreateWithoutContentInput {
  id?: ID_Input;
  fileName?: FileIndexCreateOneInput;
  size?: Int;
}

export interface MessageUpdateWithoutChatRoomDataInput {
  msgSvrId?: String;
  isSend?: Int;
  type?: Int;
  talker?: WeChatUserUpdateOneRequiredWithoutMessageInput;
  createTime?: DateTimeInput;
  content?: ContentUpdateOneInput;
}

export interface ContentUpdateOneWithoutAppInput {
  create?: ContentCreateWithoutAppInput;
  update?: ContentUpdateWithoutAppDataInput;
  upsert?: ContentUpsertWithoutAppInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ContentWhereUniqueInput;
}

export interface WeChatUserUpdateOneRequiredWithoutMessageInput {
  create?: WeChatUserCreateWithoutMessageInput;
  update?: WeChatUserUpdateWithoutMessageDataInput;
  upsert?: WeChatUserUpsertWithoutMessageInput;
  connect?: WeChatUserWhereUniqueInput;
}

export interface TextUpdateOneWithoutContentInput {
  create?: TextCreateWithoutContentInput;
  update?: TextUpdateWithoutContentDataInput;
  upsert?: TextUpsertWithoutContentInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: TextWhereUniqueInput;
}

export interface WeChatUserUpdateWithoutMessageDataInput {
  username?: String;
  alias?: String;
  conRemark?: String;
  nickname?: String;
  avatar?: AvatarUpdateOneInput;
  haveChatRoom?: ChatRoomUpdateManyWithoutOwnerInput;
  joinChatRoom?: ChatRoomUpdateManyWithoutMemberListInput;
  contact?: ContactUpdateOneWithoutWeChatUserInput;
}

export interface TextUpsertWithoutContentInput {
  update: TextUpdateWithoutContentDataInput;
  create: TextCreateWithoutContentInput;
}

export interface ChatRoomUpdateManyWithoutMemberListInput {
  create?:
    | ChatRoomCreateWithoutMemberListInput[]
    | ChatRoomCreateWithoutMemberListInput;
  delete?: ChatRoomWhereUniqueInput[] | ChatRoomWhereUniqueInput;
  connect?: ChatRoomWhereUniqueInput[] | ChatRoomWhereUniqueInput;
  set?: ChatRoomWhereUniqueInput[] | ChatRoomWhereUniqueInput;
  disconnect?: ChatRoomWhereUniqueInput[] | ChatRoomWhereUniqueInput;
  update?:
    | ChatRoomUpdateWithWhereUniqueWithoutMemberListInput[]
    | ChatRoomUpdateWithWhereUniqueWithoutMemberListInput;
  upsert?:
    | ChatRoomUpsertWithWhereUniqueWithoutMemberListInput[]
    | ChatRoomUpsertWithWhereUniqueWithoutMemberListInput;
  deleteMany?: ChatRoomScalarWhereInput[] | ChatRoomScalarWhereInput;
  updateMany?:
    | ChatRoomUpdateManyWithWhereNestedInput[]
    | ChatRoomUpdateManyWithWhereNestedInput;
}

export interface ImageUpdateWithoutContentDataInput {
  thumbnailImg?: FileIndexUpdateOneInput;
  bigImg?: FileIndexUpdateOneInput;
}

export interface ChatRoomUpdateWithWhereUniqueWithoutMemberListInput {
  where: ChatRoomWhereUniqueInput;
  data: ChatRoomUpdateWithoutMemberListDataInput;
}

export interface FileIndexUpdateDataInput {
  fileName?: String;
  mimetype?: String;
  size?: Int;
  url?: String;
}

export interface ChatRoomUpdateWithoutMemberListDataInput {
  username?: String;
  nickname?: String;
  displayName?: String;
  owner?: WeChatUserUpdateOneWithoutHaveChatRoomInput;
  modifyTime?: DateTimeInput;
  avatar?: AvatarUpdateOneInput;
  message?: MessageUpdateManyWithoutChatRoomInput;
}

export interface ImageUpsertWithoutContentInput {
  update: ImageUpdateWithoutContentDataInput;
  create: ImageCreateWithoutContentInput;
}

export interface ChatRoomUpsertWithWhereUniqueWithoutMemberListInput {
  where: ChatRoomWhereUniqueInput;
  update: ChatRoomUpdateWithoutMemberListDataInput;
  create: ChatRoomCreateWithoutMemberListInput;
}

export interface VoiceUpdateWithoutContentDataInput {
  fileName?: FileIndexUpdateOneInput;
  voiceLength?: Int;
}

export interface ChatRoomScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  nickname?: String;
  nickname_not?: String;
  nickname_in?: String[] | String;
  nickname_not_in?: String[] | String;
  nickname_lt?: String;
  nickname_lte?: String;
  nickname_gt?: String;
  nickname_gte?: String;
  nickname_contains?: String;
  nickname_not_contains?: String;
  nickname_starts_with?: String;
  nickname_not_starts_with?: String;
  nickname_ends_with?: String;
  nickname_not_ends_with?: String;
  displayName?: String;
  displayName_not?: String;
  displayName_in?: String[] | String;
  displayName_not_in?: String[] | String;
  displayName_lt?: String;
  displayName_lte?: String;
  displayName_gt?: String;
  displayName_gte?: String;
  displayName_contains?: String;
  displayName_not_contains?: String;
  displayName_starts_with?: String;
  displayName_not_starts_with?: String;
  displayName_ends_with?: String;
  displayName_not_ends_with?: String;
  modifyTime?: DateTimeInput;
  modifyTime_not?: DateTimeInput;
  modifyTime_in?: DateTimeInput[] | DateTimeInput;
  modifyTime_not_in?: DateTimeInput[] | DateTimeInput;
  modifyTime_lt?: DateTimeInput;
  modifyTime_lte?: DateTimeInput;
  modifyTime_gt?: DateTimeInput;
  modifyTime_gte?: DateTimeInput;
  AND?: ChatRoomScalarWhereInput[] | ChatRoomScalarWhereInput;
  OR?: ChatRoomScalarWhereInput[] | ChatRoomScalarWhereInput;
  NOT?: ChatRoomScalarWhereInput[] | ChatRoomScalarWhereInput;
}

export interface VideoUpdateOneWithoutContentInput {
  create?: VideoCreateWithoutContentInput;
  update?: VideoUpdateWithoutContentDataInput;
  upsert?: VideoUpsertWithoutContentInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: VideoWhereUniqueInput;
}

export interface ChatRoomUpdateManyWithWhereNestedInput {
  where: ChatRoomScalarWhereInput;
  data: ChatRoomUpdateManyDataInput;
}

export interface VoiceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: VoiceWhereInput;
  AND?: VoiceSubscriptionWhereInput[] | VoiceSubscriptionWhereInput;
}

export interface ChatRoomUpdateManyDataInput {
  username?: String;
  nickname?: String;
  displayName?: String;
  modifyTime?: DateTimeInput;
}

export interface ImageWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  thumbnailImg?: FileIndexWhereInput;
  bigImg?: FileIndexWhereInput;
  content?: ContentWhereInput;
  AND?: ImageWhereInput[] | ImageWhereInput;
}

export interface ContactUpdateOneWithoutWeChatUserInput {
  create?: ContactCreateWithoutWeChatUserInput;
  update?: ContactUpdateWithoutWeChatUserDataInput;
  upsert?: ContactUpsertWithoutWeChatUserInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ContactWhereUniqueInput;
}

export type ChatRoomWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  username?: String;
}>;

export interface ContactUpdateWithoutWeChatUserDataInput {
  type?: String;
}

export interface WeChatUserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  alias?: String;
  alias_not?: String;
  alias_in?: String[] | String;
  alias_not_in?: String[] | String;
  alias_lt?: String;
  alias_lte?: String;
  alias_gt?: String;
  alias_gte?: String;
  alias_contains?: String;
  alias_not_contains?: String;
  alias_starts_with?: String;
  alias_not_starts_with?: String;
  alias_ends_with?: String;
  alias_not_ends_with?: String;
  conRemark?: String;
  conRemark_not?: String;
  conRemark_in?: String[] | String;
  conRemark_not_in?: String[] | String;
  conRemark_lt?: String;
  conRemark_lte?: String;
  conRemark_gt?: String;
  conRemark_gte?: String;
  conRemark_contains?: String;
  conRemark_not_contains?: String;
  conRemark_starts_with?: String;
  conRemark_not_starts_with?: String;
  conRemark_ends_with?: String;
  conRemark_not_ends_with?: String;
  nickname?: String;
  nickname_not?: String;
  nickname_in?: String[] | String;
  nickname_not_in?: String[] | String;
  nickname_lt?: String;
  nickname_lte?: String;
  nickname_gt?: String;
  nickname_gte?: String;
  nickname_contains?: String;
  nickname_not_contains?: String;
  nickname_starts_with?: String;
  nickname_not_starts_with?: String;
  nickname_ends_with?: String;
  nickname_not_ends_with?: String;
  avatar?: AvatarWhereInput;
  message_some?: MessageWhereInput;
  haveChatRoom_some?: ChatRoomWhereInput;
  joinChatRoom_some?: ChatRoomWhereInput;
  contact?: ContactWhereInput;
  AND?: WeChatUserWhereInput[] | WeChatUserWhereInput;
}

export interface ContactUpsertWithoutWeChatUserInput {
  update: ContactUpdateWithoutWeChatUserDataInput;
  create: ContactCreateWithoutWeChatUserInput;
}

export interface TextWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  textMsg?: String;
  textMsg_not?: String;
  textMsg_in?: String[] | String;
  textMsg_not_in?: String[] | String;
  textMsg_lt?: String;
  textMsg_lte?: String;
  textMsg_gt?: String;
  textMsg_gte?: String;
  textMsg_contains?: String;
  textMsg_not_contains?: String;
  textMsg_starts_with?: String;
  textMsg_not_starts_with?: String;
  textMsg_ends_with?: String;
  textMsg_not_ends_with?: String;
  content?: ContentWhereInput;
  AND?: TextWhereInput[] | TextWhereInput;
}

export interface WeChatUserUpsertWithoutMessageInput {
  update: WeChatUserUpdateWithoutMessageDataInput;
  create: WeChatUserCreateWithoutMessageInput;
}

export interface AppWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  content?: ContentWhereInput;
  AND?: AppWhereInput[] | AppWhereInput;
}

export interface ContentUpdateOneInput {
  create?: ContentCreateInput;
  update?: ContentUpdateDataInput;
  upsert?: ContentUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ContentWhereUniqueInput;
}

export type ContactWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ContentUpdateDataInput {
  text?: TextUpdateOneWithoutContentInput;
  image?: ImageUpdateOneWithoutContentInput;
  voice?: VoiceUpdateOneWithoutContentInput;
  video?: VideoUpdateOneWithoutContentInput;
  file?: FileUpdateOneWithoutContentInput;
  app?: AppUpdateOneWithoutContentInput;
}

export interface VoiceUpdateManyMutationInput {
  voiceLength?: Int;
}

export interface AppUpdateOneWithoutContentInput {
  create?: AppCreateWithoutContentInput;
  update?: AppUpdateWithoutContentDataInput;
  upsert?: AppUpsertWithoutContentInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: AppWhereUniqueInput;
}

export interface ContentUpdateOneWithoutVoiceInput {
  create?: ContentCreateWithoutVoiceInput;
  update?: ContentUpdateWithoutVoiceDataInput;
  upsert?: ContentUpsertWithoutVoiceInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ContentWhereUniqueInput;
}

export interface AppUpdateWithoutContentDataInput {
  xml?: Json;
}

export interface ContentCreateOneWithoutVoiceInput {
  create?: ContentCreateWithoutVoiceInput;
  connect?: ContentWhereUniqueInput;
}

export interface AppUpsertWithoutContentInput {
  update: AppUpdateWithoutContentDataInput;
  create: AppCreateWithoutContentInput;
}

export interface ContentUpsertWithoutVideoInput {
  update: ContentUpdateWithoutVideoDataInput;
  create: ContentCreateWithoutVideoInput;
}

export interface ContentUpsertNestedInput {
  update: ContentUpdateDataInput;
  create: ContentCreateInput;
}

export type ImageWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface MessageUpsertWithWhereUniqueWithoutChatRoomInput {
  where: MessageWhereUniqueInput;
  update: MessageUpdateWithoutChatRoomDataInput;
  create: MessageCreateWithoutChatRoomInput;
}

export interface UserUpdateManyMutationInput {
  email?: String;
  name?: String;
  password?: String;
}

export interface MessageScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  msgSvrId?: String;
  msgSvrId_not?: String;
  msgSvrId_in?: String[] | String;
  msgSvrId_not_in?: String[] | String;
  msgSvrId_lt?: String;
  msgSvrId_lte?: String;
  msgSvrId_gt?: String;
  msgSvrId_gte?: String;
  msgSvrId_contains?: String;
  msgSvrId_not_contains?: String;
  msgSvrId_starts_with?: String;
  msgSvrId_not_starts_with?: String;
  msgSvrId_ends_with?: String;
  msgSvrId_not_ends_with?: String;
  isSend?: Int;
  isSend_not?: Int;
  isSend_in?: Int[] | Int;
  isSend_not_in?: Int[] | Int;
  isSend_lt?: Int;
  isSend_lte?: Int;
  isSend_gt?: Int;
  isSend_gte?: Int;
  type?: Int;
  type_not?: Int;
  type_in?: Int[] | Int;
  type_not_in?: Int[] | Int;
  type_lt?: Int;
  type_lte?: Int;
  type_gt?: Int;
  type_gte?: Int;
  createTime?: DateTimeInput;
  createTime_not?: DateTimeInput;
  createTime_in?: DateTimeInput[] | DateTimeInput;
  createTime_not_in?: DateTimeInput[] | DateTimeInput;
  createTime_lt?: DateTimeInput;
  createTime_lte?: DateTimeInput;
  createTime_gt?: DateTimeInput;
  createTime_gte?: DateTimeInput;
  AND?: MessageScalarWhereInput[] | MessageScalarWhereInput;
  OR?: MessageScalarWhereInput[] | MessageScalarWhereInput;
  NOT?: MessageScalarWhereInput[] | MessageScalarWhereInput;
}

export interface MessageUpsertWithWhereUniqueNestedInput {
  where: MessageWhereUniqueInput;
  update: MessageUpdateDataInput;
  create: MessageCreateInput;
}

export interface MessageUpdateManyWithWhereNestedInput {
  where: MessageScalarWhereInput;
  data: MessageUpdateManyDataInput;
}

export interface MessageUpdateManyInput {
  create?: MessageCreateInput[] | MessageCreateInput;
  update?:
    | MessageUpdateWithWhereUniqueNestedInput[]
    | MessageUpdateWithWhereUniqueNestedInput;
  upsert?:
    | MessageUpsertWithWhereUniqueNestedInput[]
    | MessageUpsertWithWhereUniqueNestedInput;
  delete?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  connect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  set?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  disconnect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  deleteMany?: MessageScalarWhereInput[] | MessageScalarWhereInput;
  updateMany?:
    | MessageUpdateManyWithWhereNestedInput[]
    | MessageUpdateManyWithWhereNestedInput;
}

export interface MessageUpdateManyDataInput {
  msgSvrId?: String;
  isSend?: Int;
  type?: Int;
  createTime?: DateTimeInput;
}

export interface WeChatWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  weChatOwner?: WeChatUserWhereInput;
  weChatUsers_some?: WeChatUserWhereInput;
  chatRooms_some?: ChatRoomWhereInput;
  messages_some?: MessageWhereInput;
  AND?: WeChatWhereInput[] | WeChatWhereInput;
}

export interface ChatRoomUpsertWithWhereUniqueWithoutOwnerInput {
  where: ChatRoomWhereUniqueInput;
  update: ChatRoomUpdateWithoutOwnerDataInput;
  create: ChatRoomCreateWithoutOwnerInput;
}

export interface WeChatUserUpsertWithWhereUniqueNestedInput {
  where: WeChatUserWhereUniqueInput;
  update: WeChatUserUpdateDataInput;
  create: WeChatUserCreateInput;
}

export interface WeChatUserUpsertWithWhereUniqueWithoutJoinChatRoomInput {
  where: WeChatUserWhereUniqueInput;
  update: WeChatUserUpdateWithoutJoinChatRoomDataInput;
  create: WeChatUserCreateWithoutJoinChatRoomInput;
}

export type VideoWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface WeChatUserScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  alias?: String;
  alias_not?: String;
  alias_in?: String[] | String;
  alias_not_in?: String[] | String;
  alias_lt?: String;
  alias_lte?: String;
  alias_gt?: String;
  alias_gte?: String;
  alias_contains?: String;
  alias_not_contains?: String;
  alias_starts_with?: String;
  alias_not_starts_with?: String;
  alias_ends_with?: String;
  alias_not_ends_with?: String;
  conRemark?: String;
  conRemark_not?: String;
  conRemark_in?: String[] | String;
  conRemark_not_in?: String[] | String;
  conRemark_lt?: String;
  conRemark_lte?: String;
  conRemark_gt?: String;
  conRemark_gte?: String;
  conRemark_contains?: String;
  conRemark_not_contains?: String;
  conRemark_starts_with?: String;
  conRemark_not_starts_with?: String;
  conRemark_ends_with?: String;
  conRemark_not_ends_with?: String;
  nickname?: String;
  nickname_not?: String;
  nickname_in?: String[] | String;
  nickname_not_in?: String[] | String;
  nickname_lt?: String;
  nickname_lte?: String;
  nickname_gt?: String;
  nickname_gte?: String;
  nickname_contains?: String;
  nickname_not_contains?: String;
  nickname_starts_with?: String;
  nickname_not_starts_with?: String;
  nickname_ends_with?: String;
  nickname_not_ends_with?: String;
  AND?: WeChatUserScalarWhereInput[] | WeChatUserScalarWhereInput;
  OR?: WeChatUserScalarWhereInput[] | WeChatUserScalarWhereInput;
  NOT?: WeChatUserScalarWhereInput[] | WeChatUserScalarWhereInput;
}

export interface WeChatUpdateWithWhereUniqueNestedInput {
  where: WeChatWhereUniqueInput;
  data: WeChatUpdateDataInput;
}

export interface WeChatUserUpdateManyWithWhereNestedInput {
  where: WeChatUserScalarWhereInput;
  data: WeChatUserUpdateManyDataInput;
}

export interface MessageCreateManyInput {
  create?: MessageCreateInput[] | MessageCreateInput;
  connect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
}

export interface WeChatUserUpdateManyDataInput {
  username?: String;
  alias?: String;
  conRemark?: String;
  nickname?: String;
}

export interface WeChatUserCreateInput {
  id?: ID_Input;
  username: String;
  alias?: String;
  conRemark?: String;
  nickname?: String;
  avatar?: AvatarCreateOneInput;
  message?: MessageCreateManyWithoutTalkerInput;
  haveChatRoom?: ChatRoomCreateManyWithoutOwnerInput;
  joinChatRoom?: ChatRoomCreateManyWithoutMemberListInput;
  contact?: ContactCreateOneWithoutWeChatUserInput;
}

export interface ChatRoomUpsertWithoutMessageInput {
  update: ChatRoomUpdateWithoutMessageDataInput;
  create: ChatRoomCreateWithoutMessageInput;
}

export interface WeChatCreateManyInput {
  create?: WeChatCreateInput[] | WeChatCreateInput;
  connect?: WeChatWhereUniqueInput[] | WeChatWhereUniqueInput;
}

export interface MessageUpsertWithWhereUniqueWithoutTalkerInput {
  where: MessageWhereUniqueInput;
  update: MessageUpdateWithoutTalkerDataInput;
  create: MessageCreateWithoutTalkerInput;
}

export interface ContentCreateOneWithoutAppInput {
  create?: ContentCreateWithoutAppInput;
  connect?: ContentWhereUniqueInput;
}

export interface WeChatUserUpsertWithoutHaveChatRoomInput {
  update: WeChatUserUpdateWithoutHaveChatRoomDataInput;
  create: WeChatUserCreateWithoutHaveChatRoomInput;
}

export interface ImageCreateOneWithoutContentInput {
  create?: ImageCreateWithoutContentInput;
  connect?: ImageWhereUniqueInput;
}

export interface ChatRoomUpdateManyMutationInput {
  username?: String;
  nickname?: String;
  displayName?: String;
  modifyTime?: DateTimeInput;
}

export interface VoiceCreateOneWithoutContentInput {
  create?: VoiceCreateWithoutContentInput;
  connect?: VoiceWhereUniqueInput;
}

export interface ContactCreateInput {
  id?: ID_Input;
  type: String;
  weChatUser?: WeChatUserCreateManyWithoutContactInput;
}

export interface FileCreateOneWithoutContentInput {
  create?: FileCreateWithoutContentInput;
  connect?: FileWhereUniqueInput;
}

export interface WeChatUserCreateManyWithoutContactInput {
  create?:
    | WeChatUserCreateWithoutContactInput[]
    | WeChatUserCreateWithoutContactInput;
  connect?: WeChatUserWhereUniqueInput[] | WeChatUserWhereUniqueInput;
}

export interface ContentUpdateWithoutAppDataInput {
  text?: TextUpdateOneWithoutContentInput;
  image?: ImageUpdateOneWithoutContentInput;
  voice?: VoiceUpdateOneWithoutContentInput;
  video?: VideoUpdateOneWithoutContentInput;
  file?: FileUpdateOneWithoutContentInput;
}

export interface WeChatUserCreateWithoutContactInput {
  id?: ID_Input;
  username: String;
  alias?: String;
  conRemark?: String;
  nickname?: String;
  avatar?: AvatarCreateOneInput;
  message?: MessageCreateManyWithoutTalkerInput;
  haveChatRoom?: ChatRoomCreateManyWithoutOwnerInput;
  joinChatRoom?: ChatRoomCreateManyWithoutMemberListInput;
}

export interface ImageUpdateOneWithoutContentInput {
  create?: ImageCreateWithoutContentInput;
  update?: ImageUpdateWithoutContentDataInput;
  upsert?: ImageUpsertWithoutContentInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ImageWhereUniqueInput;
}

export interface ContactUpdateInput {
  type?: String;
  weChatUser?: WeChatUserUpdateManyWithoutContactInput;
}

export interface FileIndexUpsertNestedInput {
  update: FileIndexUpdateDataInput;
  create: FileIndexCreateInput;
}

export interface WeChatUserUpdateManyWithoutContactInput {
  create?:
    | WeChatUserCreateWithoutContactInput[]
    | WeChatUserCreateWithoutContactInput;
  delete?: WeChatUserWhereUniqueInput[] | WeChatUserWhereUniqueInput;
  connect?: WeChatUserWhereUniqueInput[] | WeChatUserWhereUniqueInput;
  set?: WeChatUserWhereUniqueInput[] | WeChatUserWhereUniqueInput;
  disconnect?: WeChatUserWhereUniqueInput[] | WeChatUserWhereUniqueInput;
  update?:
    | WeChatUserUpdateWithWhereUniqueWithoutContactInput[]
    | WeChatUserUpdateWithWhereUniqueWithoutContactInput;
  upsert?:
    | WeChatUserUpsertWithWhereUniqueWithoutContactInput[]
    | WeChatUserUpsertWithWhereUniqueWithoutContactInput;
  deleteMany?: WeChatUserScalarWhereInput[] | WeChatUserScalarWhereInput;
  updateMany?:
    | WeChatUserUpdateManyWithWhereNestedInput[]
    | WeChatUserUpdateManyWithWhereNestedInput;
}

export interface VoiceUpsertWithoutContentInput {
  update: VoiceUpdateWithoutContentDataInput;
  create: VoiceCreateWithoutContentInput;
}

export interface WeChatUserUpdateWithWhereUniqueWithoutContactInput {
  where: WeChatUserWhereUniqueInput;
  data: WeChatUserUpdateWithoutContactDataInput;
}

export interface VideoSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: VideoWhereInput;
  AND?: VideoSubscriptionWhereInput[] | VideoSubscriptionWhereInput;
}

export interface WeChatUserUpdateWithoutContactDataInput {
  username?: String;
  alias?: String;
  conRemark?: String;
  nickname?: String;
  avatar?: AvatarUpdateOneInput;
  message?: MessageUpdateManyWithoutTalkerInput;
  haveChatRoom?: ChatRoomUpdateManyWithoutOwnerInput;
  joinChatRoom?: ChatRoomUpdateManyWithoutMemberListInput;
}

export interface FileIndexSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FileIndexWhereInput;
  AND?: FileIndexSubscriptionWhereInput[] | FileIndexSubscriptionWhereInput;
}

export interface WeChatUserUpsertWithWhereUniqueWithoutContactInput {
  where: WeChatUserWhereUniqueInput;
  update: WeChatUserUpdateWithoutContactDataInput;
  create: WeChatUserCreateWithoutContactInput;
}

export interface ContentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  text?: TextWhereInput;
  image?: ImageWhereInput;
  voice?: VoiceWhereInput;
  video?: VideoWhereInput;
  file?: FileWhereInput;
  app?: AppWhereInput;
  AND?: ContentWhereInput[] | ContentWhereInput;
}

export interface ContactUpdateManyMutationInput {
  type?: String;
}

export interface WeChatUserUpdateInput {
  username?: String;
  alias?: String;
  conRemark?: String;
  nickname?: String;
  avatar?: AvatarUpdateOneInput;
  message?: MessageUpdateManyWithoutTalkerInput;
  haveChatRoom?: ChatRoomUpdateManyWithoutOwnerInput;
  joinChatRoom?: ChatRoomUpdateManyWithoutMemberListInput;
  contact?: ContactUpdateOneWithoutWeChatUserInput;
}

export interface ContentUpdateInput {
  text?: TextUpdateOneWithoutContentInput;
  image?: ImageUpdateOneWithoutContentInput;
  voice?: VoiceUpdateOneWithoutContentInput;
  video?: VideoUpdateOneWithoutContentInput;
  file?: FileUpdateOneWithoutContentInput;
  app?: AppUpdateOneWithoutContentInput;
}

export type FileWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface FileCreateInput {
  id?: ID_Input;
  fileName?: FileIndexCreateOneInput;
  size?: Int;
  content?: ContentCreateOneWithoutFileInput;
}

export interface ContentUpdateOneWithoutVideoInput {
  create?: ContentCreateWithoutVideoInput;
  update?: ContentUpdateWithoutVideoDataInput;
  upsert?: ContentUpsertWithoutVideoInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ContentWhereUniqueInput;
}

export interface ContentCreateOneWithoutFileInput {
  create?: ContentCreateWithoutFileInput;
  connect?: ContentWhereUniqueInput;
}

export interface WeChatScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: WeChatScalarWhereInput[] | WeChatScalarWhereInput;
  OR?: WeChatScalarWhereInput[] | WeChatScalarWhereInput;
  NOT?: WeChatScalarWhereInput[] | WeChatScalarWhereInput;
}

export interface ContentCreateWithoutFileInput {
  id?: ID_Input;
  text?: TextCreateOneWithoutContentInput;
  image?: ImageCreateOneWithoutContentInput;
  voice?: VoiceCreateOneWithoutContentInput;
  video?: VideoCreateOneWithoutContentInput;
  app?: AppCreateOneWithoutContentInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface FileUpdateInput {
  fileName?: FileIndexUpdateOneInput;
  size?: Int;
  content?: ContentUpdateOneWithoutFileInput;
}

export interface WeChatUserUpdateManyInput {
  create?: WeChatUserCreateInput[] | WeChatUserCreateInput;
  update?:
    | WeChatUserUpdateWithWhereUniqueNestedInput[]
    | WeChatUserUpdateWithWhereUniqueNestedInput;
  upsert?:
    | WeChatUserUpsertWithWhereUniqueNestedInput[]
    | WeChatUserUpsertWithWhereUniqueNestedInput;
  delete?: WeChatUserWhereUniqueInput[] | WeChatUserWhereUniqueInput;
  connect?: WeChatUserWhereUniqueInput[] | WeChatUserWhereUniqueInput;
  set?: WeChatUserWhereUniqueInput[] | WeChatUserWhereUniqueInput;
  disconnect?: WeChatUserWhereUniqueInput[] | WeChatUserWhereUniqueInput;
  deleteMany?: WeChatUserScalarWhereInput[] | WeChatUserScalarWhereInput;
  updateMany?:
    | WeChatUserUpdateManyWithWhereNestedInput[]
    | WeChatUserUpdateManyWithWhereNestedInput;
}

export interface ContentUpdateOneWithoutFileInput {
  create?: ContentCreateWithoutFileInput;
  update?: ContentUpdateWithoutFileDataInput;
  upsert?: ContentUpsertWithoutFileInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ContentWhereUniqueInput;
}

export interface WeChatUpdateManyInput {
  create?: WeChatCreateInput[] | WeChatCreateInput;
  update?:
    | WeChatUpdateWithWhereUniqueNestedInput[]
    | WeChatUpdateWithWhereUniqueNestedInput;
  upsert?:
    | WeChatUpsertWithWhereUniqueNestedInput[]
    | WeChatUpsertWithWhereUniqueNestedInput;
  delete?: WeChatWhereUniqueInput[] | WeChatWhereUniqueInput;
  connect?: WeChatWhereUniqueInput[] | WeChatWhereUniqueInput;
  set?: WeChatWhereUniqueInput[] | WeChatWhereUniqueInput;
  disconnect?: WeChatWhereUniqueInput[] | WeChatWhereUniqueInput;
  deleteMany?: WeChatScalarWhereInput[] | WeChatScalarWhereInput;
}

export interface ContentUpdateWithoutFileDataInput {
  text?: TextUpdateOneWithoutContentInput;
  image?: ImageUpdateOneWithoutContentInput;
  voice?: VoiceUpdateOneWithoutContentInput;
  video?: VideoUpdateOneWithoutContentInput;
  app?: AppUpdateOneWithoutContentInput;
}

export type WeChatUserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  username?: String;
}>;

export interface ContentUpsertWithoutFileInput {
  update: ContentUpdateWithoutFileDataInput;
  create: ContentCreateWithoutFileInput;
}

export interface TextCreateOneWithoutContentInput {
  create?: TextCreateWithoutContentInput;
  connect?: TextWhereUniqueInput;
}

export interface FileUpdateManyMutationInput {
  size?: Int;
}

export interface VideoCreateOneWithoutContentInput {
  create?: VideoCreateWithoutContentInput;
  connect?: VideoWhereUniqueInput;
}

export interface FileIndexUpdateInput {
  fileName?: String;
  mimetype?: String;
  size?: Int;
  url?: String;
}

export interface TextUpdateWithoutContentDataInput {
  textMsg?: String;
}

export interface FileIndexUpdateManyMutationInput {
  fileName?: String;
  mimetype?: String;
  size?: Int;
  url?: String;
}

export interface VoiceUpdateOneWithoutContentInput {
  create?: VoiceCreateWithoutContentInput;
  update?: VoiceUpdateWithoutContentDataInput;
  upsert?: VoiceUpsertWithoutContentInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: VoiceWhereUniqueInput;
}

export interface ImageCreateInput {
  id?: ID_Input;
  thumbnailImg?: FileIndexCreateOneInput;
  bigImg?: FileIndexCreateOneInput;
  content?: ContentCreateOneWithoutImageInput;
}

export interface TextSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TextWhereInput;
  AND?: TextSubscriptionWhereInput[] | TextSubscriptionWhereInput;
}

export interface ContentCreateOneWithoutImageInput {
  create?: ContentCreateWithoutImageInput;
  connect?: ContentWhereUniqueInput;
}

export interface AvatarSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AvatarWhereInput;
  AND?: AvatarSubscriptionWhereInput[] | AvatarSubscriptionWhereInput;
}

export interface ContentCreateWithoutImageInput {
  id?: ID_Input;
  text?: TextCreateOneWithoutContentInput;
  voice?: VoiceCreateOneWithoutContentInput;
  video?: VideoCreateOneWithoutContentInput;
  file?: FileCreateOneWithoutContentInput;
  app?: AppCreateOneWithoutContentInput;
}

export interface VideoUpdateManyMutationInput {
  videolength?: Int;
}

export interface ImageUpdateInput {
  thumbnailImg?: FileIndexUpdateOneInput;
  bigImg?: FileIndexUpdateOneInput;
  content?: ContentUpdateOneWithoutImageInput;
}

export interface MessageUpdateDataInput {
  msgSvrId?: String;
  isSend?: Int;
  type?: Int;
  talker?: WeChatUserUpdateOneRequiredWithoutMessageInput;
  createTime?: DateTimeInput;
  chatRoom?: ChatRoomUpdateOneWithoutMessageInput;
  content?: ContentUpdateOneInput;
}

export interface ContentUpdateOneWithoutImageInput {
  create?: ContentCreateWithoutImageInput;
  update?: ContentUpdateWithoutImageDataInput;
  upsert?: ContentUpsertWithoutImageInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ContentWhereUniqueInput;
}

export interface WeChatUserUpdateOneRequiredInput {
  create?: WeChatUserCreateInput;
  update?: WeChatUserUpdateDataInput;
  upsert?: WeChatUserUpsertNestedInput;
  connect?: WeChatUserWhereUniqueInput;
}

export interface ContentUpdateWithoutImageDataInput {
  text?: TextUpdateOneWithoutContentInput;
  voice?: VoiceUpdateOneWithoutContentInput;
  video?: VideoUpdateOneWithoutContentInput;
  file?: FileUpdateOneWithoutContentInput;
  app?: AppUpdateOneWithoutContentInput;
}

export interface AppUpdateInput {
  xml?: Json;
  content?: ContentUpdateOneWithoutAppInput;
}

export interface ContentUpsertWithoutImageInput {
  update: ContentUpdateWithoutImageDataInput;
  create: ContentCreateWithoutImageInput;
}

export interface WeChatUserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: WeChatUserWhereInput;
  AND?: WeChatUserSubscriptionWhereInput[] | WeChatUserSubscriptionWhereInput;
}

export interface MessageCreateInput {
  id?: ID_Input;
  msgSvrId?: String;
  isSend?: Int;
  type?: Int;
  talker: WeChatUserCreateOneWithoutMessageInput;
  createTime?: DateTimeInput;
  chatRoom?: ChatRoomCreateOneWithoutMessageInput;
  content?: ContentCreateOneInput;
}

export interface ContentUpsertWithoutVoiceInput {
  update: ContentUpdateWithoutVoiceDataInput;
  create: ContentCreateWithoutVoiceInput;
}

export interface MessageUpdateInput {
  msgSvrId?: String;
  isSend?: Int;
  type?: Int;
  talker?: WeChatUserUpdateOneRequiredWithoutMessageInput;
  createTime?: DateTimeInput;
  chatRoom?: ChatRoomUpdateOneWithoutMessageInput;
  content?: ContentUpdateOneInput;
}

export interface ChatRoomUpdateManyInput {
  create?: ChatRoomCreateInput[] | ChatRoomCreateInput;
  update?:
    | ChatRoomUpdateWithWhereUniqueNestedInput[]
    | ChatRoomUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ChatRoomUpsertWithWhereUniqueNestedInput[]
    | ChatRoomUpsertWithWhereUniqueNestedInput;
  delete?: ChatRoomWhereUniqueInput[] | ChatRoomWhereUniqueInput;
  connect?: ChatRoomWhereUniqueInput[] | ChatRoomWhereUniqueInput;
  set?: ChatRoomWhereUniqueInput[] | ChatRoomWhereUniqueInput;
  disconnect?: ChatRoomWhereUniqueInput[] | ChatRoomWhereUniqueInput;
  deleteMany?: ChatRoomScalarWhereInput[] | ChatRoomScalarWhereInput;
  updateMany?:
    | ChatRoomUpdateManyWithWhereNestedInput[]
    | ChatRoomUpdateManyWithWhereNestedInput;
}

export interface ContentCreateWithoutTextInput {
  id?: ID_Input;
  image?: ImageCreateOneWithoutContentInput;
  voice?: VoiceCreateOneWithoutContentInput;
  video?: VideoCreateOneWithoutContentInput;
  file?: FileCreateOneWithoutContentInput;
  app?: AppCreateOneWithoutContentInput;
}

export interface ContentCreateOneWithoutTextInput {
  create?: ContentCreateWithoutTextInput;
  connect?: ContentWhereUniqueInput;
}

export interface TextCreateInput {
  id?: ID_Input;
  textMsg: String;
  content?: ContentCreateOneWithoutTextInput;
}

export interface MessageUpdateManyMutationInput {
  msgSvrId?: String;
  isSend?: Int;
  type?: Int;
  createTime?: DateTimeInput;
}

export type WeChatWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ContentCreateOneWithoutVideoInput {
  create?: ContentCreateWithoutVideoInput;
  connect?: ContentWhereUniqueInput;
}

export interface FileSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FileWhereInput;
  AND?: FileSubscriptionWhereInput[] | FileSubscriptionWhereInput;
}

export interface FileIndexUpdateOneInput {
  create?: FileIndexCreateInput;
  update?: FileIndexUpdateDataInput;
  upsert?: FileIndexUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: FileIndexWhereUniqueInput;
}

export interface FileIndexCreateOneInput {
  create?: FileIndexCreateInput;
  connect?: FileIndexWhereUniqueInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface WeChatUserPreviousValues {
  id: ID_Output;
  username: String;
  alias?: String;
  conRemark?: String;
  nickname?: String;
}

export interface WeChatUserPreviousValuesPromise
  extends Promise<WeChatUserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  username: () => Promise<String>;
  alias: () => Promise<String>;
  conRemark: () => Promise<String>;
  nickname: () => Promise<String>;
}

export interface WeChatUserPreviousValuesSubscription
  extends Promise<AsyncIterator<WeChatUserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  username: () => Promise<AsyncIterator<String>>;
  alias: () => Promise<AsyncIterator<String>>;
  conRemark: () => Promise<AsyncIterator<String>>;
  nickname: () => Promise<AsyncIterator<String>>;
}

export interface ContactEdge {
  node: Contact;
  cursor: String;
}

export interface ContactEdgePromise extends Promise<ContactEdge>, Fragmentable {
  node: <T = ContactPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ContactEdgeSubscription
  extends Promise<AsyncIterator<ContactEdge>>,
    Fragmentable {
  node: <T = ContactSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AppConnection {
  pageInfo: PageInfo;
  edges: AppEdge[];
}

export interface AppConnectionPromise
  extends Promise<AppConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AppEdge>>() => T;
  aggregate: <T = AggregateAppPromise>() => T;
}

export interface AppConnectionSubscription
  extends Promise<AsyncIterator<AppConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AppEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAppSubscription>() => T;
}

export interface ContactConnection {
  pageInfo: PageInfo;
  edges: ContactEdge[];
}

export interface ContactConnectionPromise
  extends Promise<ContactConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ContactEdge>>() => T;
  aggregate: <T = AggregateContactPromise>() => T;
}

export interface ContactConnectionSubscription
  extends Promise<AsyncIterator<ContactConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ContactEdgeSubscription>>>() => T;
  aggregate: <T = AggregateContactSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface File {
  id: ID_Output;
  size?: Int;
}

export interface FilePromise extends Promise<File>, Fragmentable {
  id: () => Promise<ID_Output>;
  fileName: <T = FileIndexPromise>() => T;
  size: () => Promise<Int>;
  content: <T = ContentPromise>() => T;
}

export interface FileSubscription
  extends Promise<AsyncIterator<File>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fileName: <T = FileIndexSubscription>() => T;
  size: () => Promise<AsyncIterator<Int>>;
  content: <T = ContentSubscription>() => T;
}

export interface AggregateWeChatUser {
  count: Int;
}

export interface AggregateWeChatUserPromise
  extends Promise<AggregateWeChatUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWeChatUserSubscription
  extends Promise<AsyncIterator<AggregateWeChatUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateChatRoom {
  count: Int;
}

export interface AggregateChatRoomPromise
  extends Promise<AggregateChatRoom>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateChatRoomSubscription
  extends Promise<AsyncIterator<AggregateChatRoom>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface WeChatUserConnection {
  pageInfo: PageInfo;
  edges: WeChatUserEdge[];
}

export interface WeChatUserConnectionPromise
  extends Promise<WeChatUserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WeChatUserEdge>>() => T;
  aggregate: <T = AggregateWeChatUserPromise>() => T;
}

export interface WeChatUserConnectionSubscription
  extends Promise<AsyncIterator<WeChatUserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<WeChatUserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateWeChatUserSubscription>() => T;
}

export interface App {
  id: ID_Output;
  xml?: Json;
}

export interface AppPromise extends Promise<App>, Fragmentable {
  id: () => Promise<ID_Output>;
  xml: () => Promise<Json>;
  content: <T = ContentPromise>() => T;
}

export interface AppSubscription
  extends Promise<AsyncIterator<App>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  xml: () => Promise<AsyncIterator<Json>>;
  content: <T = ContentSubscription>() => T;
}

export interface WeChatEdge {
  node: WeChat;
  cursor: String;
}

export interface WeChatEdgePromise extends Promise<WeChatEdge>, Fragmentable {
  node: <T = WeChatPromise>() => T;
  cursor: () => Promise<String>;
}

export interface WeChatEdgeSubscription
  extends Promise<AsyncIterator<WeChatEdge>>,
    Fragmentable {
  node: <T = WeChatSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AppSubscriptionPayload {
  mutation: MutationType;
  node: App;
  updatedFields: String[];
  previousValues: AppPreviousValues;
}

export interface AppSubscriptionPayloadPromise
  extends Promise<AppSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AppPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AppPreviousValuesPromise>() => T;
}

export interface AppSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AppSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AppSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AppPreviousValuesSubscription>() => T;
}

export interface AggregateVoice {
  count: Int;
}

export interface AggregateVoicePromise
  extends Promise<AggregateVoice>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVoiceSubscription
  extends Promise<AsyncIterator<AggregateVoice>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AppPreviousValues {
  id: ID_Output;
  xml?: Json;
}

export interface AppPreviousValuesPromise
  extends Promise<AppPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  xml: () => Promise<Json>;
}

export interface AppPreviousValuesSubscription
  extends Promise<AsyncIterator<AppPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  xml: () => Promise<AsyncIterator<Json>>;
}

export interface VoiceConnection {
  pageInfo: PageInfo;
  edges: VoiceEdge[];
}

export interface VoiceConnectionPromise
  extends Promise<VoiceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VoiceEdge>>() => T;
  aggregate: <T = AggregateVoicePromise>() => T;
}

export interface VoiceConnectionSubscription
  extends Promise<AsyncIterator<VoiceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VoiceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVoiceSubscription>() => T;
}

export interface ChatRoomEdge {
  node: ChatRoom;
  cursor: String;
}

export interface ChatRoomEdgePromise
  extends Promise<ChatRoomEdge>,
    Fragmentable {
  node: <T = ChatRoomPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ChatRoomEdgeSubscription
  extends Promise<AsyncIterator<ChatRoomEdge>>,
    Fragmentable {
  node: <T = ChatRoomSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateVideo {
  count: Int;
}

export interface AggregateVideoPromise
  extends Promise<AggregateVideo>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVideoSubscription
  extends Promise<AsyncIterator<AggregateVideo>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AvatarSubscriptionPayload {
  mutation: MutationType;
  node: Avatar;
  updatedFields: String[];
  previousValues: AvatarPreviousValues;
}

export interface AvatarSubscriptionPayloadPromise
  extends Promise<AvatarSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AvatarPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AvatarPreviousValuesPromise>() => T;
}

export interface AvatarSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AvatarSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AvatarSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AvatarPreviousValuesSubscription>() => T;
}

export interface VideoConnection {
  pageInfo: PageInfo;
  edges: VideoEdge[];
}

export interface VideoConnectionPromise
  extends Promise<VideoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VideoEdge>>() => T;
  aggregate: <T = AggregateVideoPromise>() => T;
}

export interface VideoConnectionSubscription
  extends Promise<AsyncIterator<VideoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VideoEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVideoSubscription>() => T;
}

export interface AvatarPreviousValues {
  id: ID_Output;
}

export interface AvatarPreviousValuesPromise
  extends Promise<AvatarPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface AvatarPreviousValuesSubscription
  extends Promise<AsyncIterator<AvatarPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ChatRoomConnection {
  pageInfo: PageInfo;
  edges: ChatRoomEdge[];
}

export interface ChatRoomConnectionPromise
  extends Promise<ChatRoomConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ChatRoomEdge>>() => T;
  aggregate: <T = AggregateChatRoomPromise>() => T;
}

export interface ChatRoomConnectionSubscription
  extends Promise<AsyncIterator<ChatRoomConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ChatRoomEdgeSubscription>>>() => T;
  aggregate: <T = AggregateChatRoomSubscription>() => T;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface ChatRoomSubscriptionPayload {
  mutation: MutationType;
  node: ChatRoom;
  updatedFields: String[];
  previousValues: ChatRoomPreviousValues;
}

export interface ChatRoomSubscriptionPayloadPromise
  extends Promise<ChatRoomSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ChatRoomPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ChatRoomPreviousValuesPromise>() => T;
}

export interface ChatRoomSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ChatRoomSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ChatRoomSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ChatRoomPreviousValuesSubscription>() => T;
}

export interface WeChat {
  id: ID_Output;
}

export interface WeChatPromise extends Promise<WeChat>, Fragmentable {
  id: () => Promise<ID_Output>;
  weChatOwner: <T = WeChatUserPromise>() => T;
  weChatUsers: <T = FragmentableArray<WeChatUser>>(args?: {
    where?: WeChatUserWhereInput;
    orderBy?: WeChatUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  chatRooms: <T = FragmentableArray<ChatRoom>>(args?: {
    where?: ChatRoomWhereInput;
    orderBy?: ChatRoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  messages: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface WeChatSubscription
  extends Promise<AsyncIterator<WeChat>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  weChatOwner: <T = WeChatUserSubscription>() => T;
  weChatUsers: <T = Promise<AsyncIterator<WeChatUserSubscription>>>(args?: {
    where?: WeChatUserWhereInput;
    orderBy?: WeChatUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  chatRooms: <T = Promise<AsyncIterator<ChatRoomSubscription>>>(args?: {
    where?: ChatRoomWhereInput;
    orderBy?: ChatRoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  messages: <T = Promise<AsyncIterator<MessageSubscription>>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ChatRoomPreviousValues {
  id: ID_Output;
  username: String;
  nickname?: String;
  displayName: String;
  modifyTime?: DateTimeOutput;
}

export interface ChatRoomPreviousValuesPromise
  extends Promise<ChatRoomPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  username: () => Promise<String>;
  nickname: () => Promise<String>;
  displayName: () => Promise<String>;
  modifyTime: () => Promise<DateTimeOutput>;
}

export interface ChatRoomPreviousValuesSubscription
  extends Promise<AsyncIterator<ChatRoomPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  username: () => Promise<AsyncIterator<String>>;
  nickname: () => Promise<AsyncIterator<String>>;
  displayName: () => Promise<AsyncIterator<String>>;
  modifyTime: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface User {
  id: ID_Output;
  email: String;
  name: String;
  password: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  name: () => Promise<String>;
  password: () => Promise<String>;
  weChat: <T = FragmentableArray<WeChat>>(args?: {
    where?: WeChatWhereInput;
    orderBy?: WeChatOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  weChat: <T = Promise<AsyncIterator<WeChatSubscription>>>(args?: {
    where?: WeChatWhereInput;
    orderBy?: WeChatOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Contact {
  id: ID_Output;
  type: String;
}

export interface ContactPromise extends Promise<Contact>, Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<String>;
  weChatUser: <T = FragmentableArray<WeChatUser>>(args?: {
    where?: WeChatUserWhereInput;
    orderBy?: WeChatUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ContactSubscription
  extends Promise<AsyncIterator<Contact>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<String>>;
  weChatUser: <T = Promise<AsyncIterator<WeChatUserSubscription>>>(args?: {
    where?: WeChatUserWhereInput;
    orderBy?: WeChatUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TextEdge {
  node: Text;
  cursor: String;
}

export interface TextEdgePromise extends Promise<TextEdge>, Fragmentable {
  node: <T = TextPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TextEdgeSubscription
  extends Promise<AsyncIterator<TextEdge>>,
    Fragmentable {
  node: <T = TextSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ContactSubscriptionPayload {
  mutation: MutationType;
  node: Contact;
  updatedFields: String[];
  previousValues: ContactPreviousValues;
}

export interface ContactSubscriptionPayloadPromise
  extends Promise<ContactSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ContactPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ContactPreviousValuesPromise>() => T;
}

export interface ContactSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ContactSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ContactSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ContactPreviousValuesSubscription>() => T;
}

export interface Image {
  id: ID_Output;
}

export interface ImagePromise extends Promise<Image>, Fragmentable {
  id: () => Promise<ID_Output>;
  thumbnailImg: <T = FileIndexPromise>() => T;
  bigImg: <T = FileIndexPromise>() => T;
  content: <T = ContentPromise>() => T;
}

export interface ImageSubscription
  extends Promise<AsyncIterator<Image>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  thumbnailImg: <T = FileIndexSubscription>() => T;
  bigImg: <T = FileIndexSubscription>() => T;
  content: <T = ContentSubscription>() => T;
}

export interface ContactPreviousValues {
  id: ID_Output;
  type: String;
}

export interface ContactPreviousValuesPromise
  extends Promise<ContactPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<String>;
}

export interface ContactPreviousValuesSubscription
  extends Promise<AsyncIterator<ContactPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<String>>;
}

export interface MessageEdge {
  node: Message;
  cursor: String;
}

export interface MessageEdgePromise extends Promise<MessageEdge>, Fragmentable {
  node: <T = MessagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface MessageEdgeSubscription
  extends Promise<AsyncIterator<MessageEdge>>,
    Fragmentable {
  node: <T = MessageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Message {
  id: ID_Output;
  msgSvrId?: String;
  isSend?: Int;
  type?: Int;
  createTime?: DateTimeOutput;
}

export interface MessagePromise extends Promise<Message>, Fragmentable {
  id: () => Promise<ID_Output>;
  msgSvrId: () => Promise<String>;
  isSend: () => Promise<Int>;
  type: () => Promise<Int>;
  talker: <T = WeChatUserPromise>() => T;
  createTime: () => Promise<DateTimeOutput>;
  chatRoom: <T = ChatRoomPromise>() => T;
  content: <T = ContentPromise>() => T;
}

export interface MessageSubscription
  extends Promise<AsyncIterator<Message>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  msgSvrId: () => Promise<AsyncIterator<String>>;
  isSend: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<Int>>;
  talker: <T = WeChatUserSubscription>() => T;
  createTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  chatRoom: <T = ChatRoomSubscription>() => T;
  content: <T = ContentSubscription>() => T;
}

export interface AggregateImage {
  count: Int;
}

export interface AggregateImagePromise
  extends Promise<AggregateImage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateImageSubscription
  extends Promise<AsyncIterator<AggregateImage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ContentSubscriptionPayload {
  mutation: MutationType;
  node: Content;
  updatedFields: String[];
  previousValues: ContentPreviousValues;
}

export interface ContentSubscriptionPayloadPromise
  extends Promise<ContentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ContentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ContentPreviousValuesPromise>() => T;
}

export interface ContentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ContentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ContentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ContentPreviousValuesSubscription>() => T;
}

export interface ImageConnection {
  pageInfo: PageInfo;
  edges: ImageEdge[];
}

export interface ImageConnectionPromise
  extends Promise<ImageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ImageEdge>>() => T;
  aggregate: <T = AggregateImagePromise>() => T;
}

export interface ImageConnectionSubscription
  extends Promise<AsyncIterator<ImageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ImageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateImageSubscription>() => T;
}

export interface ContentPreviousValues {
  id: ID_Output;
}

export interface ContentPreviousValuesPromise
  extends Promise<ContentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface ContentPreviousValuesSubscription
  extends Promise<AsyncIterator<ContentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AggregateFileIndex {
  count: Int;
}

export interface AggregateFileIndexPromise
  extends Promise<AggregateFileIndex>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFileIndexSubscription
  extends Promise<AsyncIterator<AggregateFileIndex>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ImageEdge {
  node: Image;
  cursor: String;
}

export interface ImageEdgePromise extends Promise<ImageEdge>, Fragmentable {
  node: <T = ImagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ImageEdgeSubscription
  extends Promise<AsyncIterator<ImageEdge>>,
    Fragmentable {
  node: <T = ImageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface VoicePreviousValues {
  id: ID_Output;
  voiceLength?: Int;
}

export interface VoicePreviousValuesPromise
  extends Promise<VoicePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  voiceLength: () => Promise<Int>;
}

export interface VoicePreviousValuesSubscription
  extends Promise<AsyncIterator<VoicePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  voiceLength: () => Promise<AsyncIterator<Int>>;
}

export interface FileIndex {
  id: ID_Output;
  fileName: String;
  mimetype: String;
  size: Int;
  url?: String;
}

export interface FileIndexPromise extends Promise<FileIndex>, Fragmentable {
  id: () => Promise<ID_Output>;
  fileName: () => Promise<String>;
  mimetype: () => Promise<String>;
  size: () => Promise<Int>;
  url: () => Promise<String>;
}

export interface FileIndexSubscription
  extends Promise<AsyncIterator<FileIndex>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fileName: () => Promise<AsyncIterator<String>>;
  mimetype: () => Promise<AsyncIterator<String>>;
  size: () => Promise<AsyncIterator<Int>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface FileIndexConnection {
  pageInfo: PageInfo;
  edges: FileIndexEdge[];
}

export interface FileIndexConnectionPromise
  extends Promise<FileIndexConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FileIndexEdge>>() => T;
  aggregate: <T = AggregateFileIndexPromise>() => T;
}

export interface FileIndexConnectionSubscription
  extends Promise<AsyncIterator<FileIndexConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FileIndexEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFileIndexSubscription>() => T;
}

export interface FileIndexEdge {
  node: FileIndex;
  cursor: String;
}

export interface FileIndexEdgePromise
  extends Promise<FileIndexEdge>,
    Fragmentable {
  node: <T = FileIndexPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FileIndexEdgeSubscription
  extends Promise<AsyncIterator<FileIndexEdge>>,
    Fragmentable {
  node: <T = FileIndexSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FileEdge {
  node: File;
  cursor: String;
}

export interface FileEdgePromise extends Promise<FileEdge>, Fragmentable {
  node: <T = FilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface FileEdgeSubscription
  extends Promise<AsyncIterator<FileEdge>>,
    Fragmentable {
  node: <T = FileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AppEdge {
  node: App;
  cursor: String;
}

export interface AppEdgePromise extends Promise<AppEdge>, Fragmentable {
  node: <T = AppPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AppEdgeSubscription
  extends Promise<AsyncIterator<AppEdge>>,
    Fragmentable {
  node: <T = AppSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Voice {
  id: ID_Output;
  voiceLength?: Int;
}

export interface VoicePromise extends Promise<Voice>, Fragmentable {
  id: () => Promise<ID_Output>;
  fileName: <T = FileIndexPromise>() => T;
  voiceLength: () => Promise<Int>;
  content: <T = ContentPromise>() => T;
}

export interface VoiceSubscription
  extends Promise<AsyncIterator<Voice>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fileName: <T = FileIndexSubscription>() => T;
  voiceLength: () => Promise<AsyncIterator<Int>>;
  content: <T = ContentSubscription>() => T;
}

export interface FileSubscriptionPayload {
  mutation: MutationType;
  node: File;
  updatedFields: String[];
  previousValues: FilePreviousValues;
}

export interface FileSubscriptionPayloadPromise
  extends Promise<FileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FilePreviousValuesPromise>() => T;
}

export interface FileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FilePreviousValuesSubscription>() => T;
}

export interface ContentEdge {
  node: Content;
  cursor: String;
}

export interface ContentEdgePromise extends Promise<ContentEdge>, Fragmentable {
  node: <T = ContentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ContentEdgeSubscription
  extends Promise<AsyncIterator<ContentEdge>>,
    Fragmentable {
  node: <T = ContentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FilePreviousValues {
  id: ID_Output;
  size?: Int;
}

export interface FilePreviousValuesPromise
  extends Promise<FilePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  size: () => Promise<Int>;
}

export interface FilePreviousValuesSubscription
  extends Promise<AsyncIterator<FilePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  size: () => Promise<AsyncIterator<Int>>;
}

export interface Video {
  id: ID_Output;
  videolength?: Int;
}

export interface VideoPromise extends Promise<Video>, Fragmentable {
  id: () => Promise<ID_Output>;
  fileName: <T = FileIndexPromise>() => T;
  thumbnailImg: <T = FileIndexPromise>() => T;
  videolength: () => Promise<Int>;
  content: <T = ContentPromise>() => T;
}

export interface VideoSubscription
  extends Promise<AsyncIterator<Video>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fileName: <T = FileIndexSubscription>() => T;
  thumbnailImg: <T = FileIndexSubscription>() => T;
  videolength: () => Promise<AsyncIterator<Int>>;
  content: <T = ContentSubscription>() => T;
}

export interface WeChatUser {
  id: ID_Output;
  username: String;
  alias?: String;
  conRemark?: String;
  nickname?: String;
}

export interface WeChatUserPromise extends Promise<WeChatUser>, Fragmentable {
  id: () => Promise<ID_Output>;
  username: () => Promise<String>;
  alias: () => Promise<String>;
  conRemark: () => Promise<String>;
  nickname: () => Promise<String>;
  avatar: <T = AvatarPromise>() => T;
  message: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  haveChatRoom: <T = FragmentableArray<ChatRoom>>(args?: {
    where?: ChatRoomWhereInput;
    orderBy?: ChatRoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  joinChatRoom: <T = FragmentableArray<ChatRoom>>(args?: {
    where?: ChatRoomWhereInput;
    orderBy?: ChatRoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  contact: <T = ContactPromise>() => T;
}

export interface WeChatUserSubscription
  extends Promise<AsyncIterator<WeChatUser>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  username: () => Promise<AsyncIterator<String>>;
  alias: () => Promise<AsyncIterator<String>>;
  conRemark: () => Promise<AsyncIterator<String>>;
  nickname: () => Promise<AsyncIterator<String>>;
  avatar: <T = AvatarSubscription>() => T;
  message: <T = Promise<AsyncIterator<MessageSubscription>>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  haveChatRoom: <T = Promise<AsyncIterator<ChatRoomSubscription>>>(args?: {
    where?: ChatRoomWhereInput;
    orderBy?: ChatRoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  joinChatRoom: <T = Promise<AsyncIterator<ChatRoomSubscription>>>(args?: {
    where?: ChatRoomWhereInput;
    orderBy?: ChatRoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  contact: <T = ContactSubscription>() => T;
}

export interface WeChatUserSubscriptionPayload {
  mutation: MutationType;
  node: WeChatUser;
  updatedFields: String[];
  previousValues: WeChatUserPreviousValues;
}

export interface WeChatUserSubscriptionPayloadPromise
  extends Promise<WeChatUserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WeChatUserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WeChatUserPreviousValuesPromise>() => T;
}

export interface WeChatUserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WeChatUserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WeChatUserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WeChatUserPreviousValuesSubscription>() => T;
}

export interface FileIndexSubscriptionPayload {
  mutation: MutationType;
  node: FileIndex;
  updatedFields: String[];
  previousValues: FileIndexPreviousValues;
}

export interface FileIndexSubscriptionPayloadPromise
  extends Promise<FileIndexSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FileIndexPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FileIndexPreviousValuesPromise>() => T;
}

export interface FileIndexSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FileIndexSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FileIndexSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FileIndexPreviousValuesSubscription>() => T;
}

export interface WeChatUserEdge {
  node: WeChatUser;
  cursor: String;
}

export interface WeChatUserEdgePromise
  extends Promise<WeChatUserEdge>,
    Fragmentable {
  node: <T = WeChatUserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface WeChatUserEdgeSubscription
  extends Promise<AsyncIterator<WeChatUserEdge>>,
    Fragmentable {
  node: <T = WeChatUserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FileIndexPreviousValues {
  id: ID_Output;
  fileName: String;
  mimetype: String;
  size: Int;
  url?: String;
}

export interface FileIndexPreviousValuesPromise
  extends Promise<FileIndexPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fileName: () => Promise<String>;
  mimetype: () => Promise<String>;
  size: () => Promise<Int>;
  url: () => Promise<String>;
}

export interface FileIndexPreviousValuesSubscription
  extends Promise<AsyncIterator<FileIndexPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fileName: () => Promise<AsyncIterator<String>>;
  mimetype: () => Promise<AsyncIterator<String>>;
  size: () => Promise<AsyncIterator<Int>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface WeChatConnection {
  pageInfo: PageInfo;
  edges: WeChatEdge[];
}

export interface WeChatConnectionPromise
  extends Promise<WeChatConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WeChatEdge>>() => T;
  aggregate: <T = AggregateWeChatPromise>() => T;
}

export interface WeChatConnectionSubscription
  extends Promise<AsyncIterator<WeChatConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<WeChatEdgeSubscription>>>() => T;
  aggregate: <T = AggregateWeChatSubscription>() => T;
}

export interface ChatRoom {
  id: ID_Output;
  username: String;
  nickname?: String;
  displayName: String;
  modifyTime?: DateTimeOutput;
}

export interface ChatRoomPromise extends Promise<ChatRoom>, Fragmentable {
  id: () => Promise<ID_Output>;
  username: () => Promise<String>;
  nickname: () => Promise<String>;
  displayName: () => Promise<String>;
  owner: <T = WeChatUserPromise>() => T;
  memberList: <T = FragmentableArray<WeChatUser>>(args?: {
    where?: WeChatUserWhereInput;
    orderBy?: WeChatUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  modifyTime: () => Promise<DateTimeOutput>;
  avatar: <T = AvatarPromise>() => T;
  message: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ChatRoomSubscription
  extends Promise<AsyncIterator<ChatRoom>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  username: () => Promise<AsyncIterator<String>>;
  nickname: () => Promise<AsyncIterator<String>>;
  displayName: () => Promise<AsyncIterator<String>>;
  owner: <T = WeChatUserSubscription>() => T;
  memberList: <T = Promise<AsyncIterator<WeChatUserSubscription>>>(args?: {
    where?: WeChatUserWhereInput;
    orderBy?: WeChatUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  modifyTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  avatar: <T = AvatarSubscription>() => T;
  message: <T = Promise<AsyncIterator<MessageSubscription>>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface WeChatPreviousValues {
  id: ID_Output;
}

export interface WeChatPreviousValuesPromise
  extends Promise<WeChatPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface WeChatPreviousValuesSubscription
  extends Promise<AsyncIterator<WeChatPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface ImageSubscriptionPayload {
  mutation: MutationType;
  node: Image;
  updatedFields: String[];
  previousValues: ImagePreviousValues;
}

export interface ImageSubscriptionPayloadPromise
  extends Promise<ImageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ImagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ImagePreviousValuesPromise>() => T;
}

export interface ImageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ImageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ImageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ImagePreviousValuesSubscription>() => T;
}

export interface Content {
  id: ID_Output;
}

export interface ContentPromise extends Promise<Content>, Fragmentable {
  id: () => Promise<ID_Output>;
  text: <T = TextPromise>() => T;
  image: <T = ImagePromise>() => T;
  voice: <T = VoicePromise>() => T;
  video: <T = VideoPromise>() => T;
  file: <T = FilePromise>() => T;
  app: <T = AppPromise>() => T;
}

export interface ContentSubscription
  extends Promise<AsyncIterator<Content>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: <T = TextSubscription>() => T;
  image: <T = ImageSubscription>() => T;
  voice: <T = VoiceSubscription>() => T;
  video: <T = VideoSubscription>() => T;
  file: <T = FileSubscription>() => T;
  app: <T = AppSubscription>() => T;
}

export interface ImagePreviousValues {
  id: ID_Output;
}

export interface ImagePreviousValuesPromise
  extends Promise<ImagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface ImagePreviousValuesSubscription
  extends Promise<AsyncIterator<ImagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface Text {
  id: ID_Output;
  textMsg: String;
}

export interface TextPromise extends Promise<Text>, Fragmentable {
  id: () => Promise<ID_Output>;
  textMsg: () => Promise<String>;
  content: <T = ContentPromise>() => T;
}

export interface TextSubscription
  extends Promise<AsyncIterator<Text>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  textMsg: () => Promise<AsyncIterator<String>>;
  content: <T = ContentSubscription>() => T;
}

export interface AggregateAvatar {
  count: Int;
}

export interface AggregateAvatarPromise
  extends Promise<AggregateAvatar>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAvatarSubscription
  extends Promise<AsyncIterator<AggregateAvatar>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateText {
  count: Int;
}

export interface AggregateTextPromise
  extends Promise<AggregateText>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTextSubscription
  extends Promise<AsyncIterator<AggregateText>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MessageSubscriptionPayload {
  mutation: MutationType;
  node: Message;
  updatedFields: String[];
  previousValues: MessagePreviousValues;
}

export interface MessageSubscriptionPayloadPromise
  extends Promise<MessageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MessagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MessagePreviousValuesPromise>() => T;
}

export interface MessageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MessageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MessageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MessagePreviousValuesSubscription>() => T;
}

export interface AggregateMessage {
  count: Int;
}

export interface AggregateMessagePromise
  extends Promise<AggregateMessage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMessageSubscription
  extends Promise<AsyncIterator<AggregateMessage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MessagePreviousValues {
  id: ID_Output;
  msgSvrId?: String;
  isSend?: Int;
  type?: Int;
  createTime?: DateTimeOutput;
}

export interface MessagePreviousValuesPromise
  extends Promise<MessagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  msgSvrId: () => Promise<String>;
  isSend: () => Promise<Int>;
  type: () => Promise<Int>;
  createTime: () => Promise<DateTimeOutput>;
}

export interface MessagePreviousValuesSubscription
  extends Promise<AsyncIterator<MessagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  msgSvrId: () => Promise<AsyncIterator<String>>;
  isSend: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<Int>>;
  createTime: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateFile {
  count: Int;
}

export interface AggregateFilePromise
  extends Promise<AggregateFile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFileSubscription
  extends Promise<AsyncIterator<AggregateFile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AvatarEdge {
  node: Avatar;
  cursor: String;
}

export interface AvatarEdgePromise extends Promise<AvatarEdge>, Fragmentable {
  node: <T = AvatarPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AvatarEdgeSubscription
  extends Promise<AsyncIterator<AvatarEdge>>,
    Fragmentable {
  node: <T = AvatarSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateContent {
  count: Int;
}

export interface AggregateContentPromise
  extends Promise<AggregateContent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateContentSubscription
  extends Promise<AsyncIterator<AggregateContent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TextSubscriptionPayload {
  mutation: MutationType;
  node: Text;
  updatedFields: String[];
  previousValues: TextPreviousValues;
}

export interface TextSubscriptionPayloadPromise
  extends Promise<TextSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TextPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TextPreviousValuesPromise>() => T;
}

export interface TextSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TextSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TextSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TextPreviousValuesSubscription>() => T;
}

export interface AggregateContact {
  count: Int;
}

export interface AggregateContactPromise
  extends Promise<AggregateContact>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateContactSubscription
  extends Promise<AsyncIterator<AggregateContact>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TextPreviousValues {
  id: ID_Output;
  textMsg: String;
}

export interface TextPreviousValuesPromise
  extends Promise<TextPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  textMsg: () => Promise<String>;
}

export interface TextPreviousValuesSubscription
  extends Promise<AsyncIterator<TextPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  textMsg: () => Promise<AsyncIterator<String>>;
}

export interface AggregateWeChat {
  count: Int;
}

export interface AggregateWeChatPromise
  extends Promise<AggregateWeChat>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWeChatSubscription
  extends Promise<AsyncIterator<AggregateWeChat>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AvatarConnection {
  pageInfo: PageInfo;
  edges: AvatarEdge[];
}

export interface AvatarConnectionPromise
  extends Promise<AvatarConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AvatarEdge>>() => T;
  aggregate: <T = AggregateAvatarPromise>() => T;
}

export interface AvatarConnectionSubscription
  extends Promise<AsyncIterator<AvatarConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AvatarEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAvatarSubscription>() => T;
}

export interface VideoEdge {
  node: Video;
  cursor: String;
}

export interface VideoEdgePromise extends Promise<VideoEdge>, Fragmentable {
  node: <T = VideoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface VideoEdgeSubscription
  extends Promise<AsyncIterator<VideoEdge>>,
    Fragmentable {
  node: <T = VideoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface WeChatSubscriptionPayload {
  mutation: MutationType;
  node: WeChat;
  updatedFields: String[];
  previousValues: WeChatPreviousValues;
}

export interface WeChatSubscriptionPayloadPromise
  extends Promise<WeChatSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WeChatPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WeChatPreviousValuesPromise>() => T;
}

export interface WeChatSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WeChatSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WeChatSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WeChatPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  email: String;
  name: String;
  password: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  name: () => Promise<String>;
  password: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
}

export interface MessageConnection {
  pageInfo: PageInfo;
  edges: MessageEdge[];
}

export interface MessageConnectionPromise
  extends Promise<MessageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MessageEdge>>() => T;
  aggregate: <T = AggregateMessagePromise>() => T;
}

export interface MessageConnectionSubscription
  extends Promise<AsyncIterator<MessageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MessageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMessageSubscription>() => T;
}

export interface Avatar {
  id: ID_Output;
}

export interface AvatarPromise extends Promise<Avatar>, Fragmentable {
  id: () => Promise<ID_Output>;
  thumbnailImg: <T = FileIndexPromise>() => T;
  bigImg: <T = FileIndexPromise>() => T;
}

export interface AvatarSubscription
  extends Promise<AsyncIterator<Avatar>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  thumbnailImg: <T = FileIndexSubscription>() => T;
  bigImg: <T = FileIndexSubscription>() => T;
}

export interface ContentConnection {
  pageInfo: PageInfo;
  edges: ContentEdge[];
}

export interface ContentConnectionPromise
  extends Promise<ContentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ContentEdge>>() => T;
  aggregate: <T = AggregateContentPromise>() => T;
}

export interface ContentConnectionSubscription
  extends Promise<AsyncIterator<ContentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ContentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateContentSubscription>() => T;
}

export interface VoiceEdge {
  node: Voice;
  cursor: String;
}

export interface VoiceEdgePromise extends Promise<VoiceEdge>, Fragmentable {
  node: <T = VoicePromise>() => T;
  cursor: () => Promise<String>;
}

export interface VoiceEdgeSubscription
  extends Promise<AsyncIterator<VoiceEdge>>,
    Fragmentable {
  node: <T = VoiceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface VoiceSubscriptionPayload {
  mutation: MutationType;
  node: Voice;
  updatedFields: String[];
  previousValues: VoicePreviousValues;
}

export interface VoiceSubscriptionPayloadPromise
  extends Promise<VoiceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VoicePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VoicePreviousValuesPromise>() => T;
}

export interface VoiceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VoiceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VoiceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VoicePreviousValuesSubscription>() => T;
}

export interface AggregateApp {
  count: Int;
}

export interface AggregateAppPromise
  extends Promise<AggregateApp>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAppSubscription
  extends Promise<AsyncIterator<AggregateApp>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VideoPreviousValues {
  id: ID_Output;
  videolength?: Int;
}

export interface VideoPreviousValuesPromise
  extends Promise<VideoPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  videolength: () => Promise<Int>;
}

export interface VideoPreviousValuesSubscription
  extends Promise<AsyncIterator<VideoPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  videolength: () => Promise<AsyncIterator<Int>>;
}

export interface VideoSubscriptionPayload {
  mutation: MutationType;
  node: Video;
  updatedFields: String[];
  previousValues: VideoPreviousValues;
}

export interface VideoSubscriptionPayloadPromise
  extends Promise<VideoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VideoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VideoPreviousValuesPromise>() => T;
}

export interface VideoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VideoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VideoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VideoPreviousValuesSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface FileConnection {
  pageInfo: PageInfo;
  edges: FileEdge[];
}

export interface FileConnectionPromise
  extends Promise<FileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FileEdge>>() => T;
  aggregate: <T = AggregateFilePromise>() => T;
}

export interface FileConnectionSubscription
  extends Promise<AsyncIterator<FileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FileEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFileSubscription>() => T;
}

export interface TextConnection {
  pageInfo: PageInfo;
  edges: TextEdge[];
}

export interface TextConnectionPromise
  extends Promise<TextConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TextEdge>>() => T;
  aggregate: <T = AggregateTextPromise>() => T;
}

export interface TextConnectionSubscription
  extends Promise<AsyncIterator<TextConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TextEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTextSubscription>() => T;
}

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Json = any;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "WeChat",
    embedded: false
  },
  {
    name: "WeChatUser",
    embedded: false
  },
  {
    name: "ChatRoom",
    embedded: false
  },
  {
    name: "Avatar",
    embedded: false
  },
  {
    name: "Contact",
    embedded: false
  },
  {
    name: "Message",
    embedded: false
  },
  {
    name: "Content",
    embedded: false
  },
  {
    name: "Text",
    embedded: false
  },
  {
    name: "Image",
    embedded: false
  },
  {
    name: "Voice",
    embedded: false
  },
  {
    name: "Video",
    embedded: false
  },
  {
    name: "File",
    embedded: false
  },
  {
    name: "App",
    embedded: false
  },
  {
    name: "FileIndex",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
