import * as R from 'ramda'
import { marbles } from 'rxjs-marbles/jest'

import { asyncMap, randomMd5, cache, groupsOf } from '../../../utils'
import { map, filter, first, pluck, scan } from 'rxjs/operators'
import { from, Subject } from 'rxjs'

describe('asyncMap', () => {
  it('Return promise on the attribute', async () => {
    const data = {
      a: Promise.resolve(1),
      b: new Promise(function(resolve) {
        setTimeout(() => {
          resolve(2)
        }, 500)
      }),
    }
    const result = await asyncMap((key, parent) => {
      const el = parent[key]
      if (el.then) {
        return from(el).pipe(map(v => (parent[key] = v)))
      }
    }, data)
    expect(result).toEqual({ a: 1, b: 2 })
    expect(result).not.toEqual(data)
  })
  it('Return promise on the nesting attribute', async () => {
    const data = {
      a: Promise.resolve(1),
      b: {
        c: new Promise(function(resolve) {
          setTimeout(() => {
            resolve(2)
          }, 500)
        }),
      },
    }
    const result = await asyncMap((key, parent) => {
      const el = parent[key]
      if (el.then) {
        return from(el).pipe(map(v => (parent[key] = v)))
      }
    }, data)
    expect(result).toEqual({ a: 1, b: { c: 2 } })
    expect(result).not.toEqual(data)
  })
  it('Use Subject', async () => {
    const store = new Subject()
    const store$ = store.pipe(
      scan(
        /**
         * @param {object} acc
         * @param {{key:string,value:number}} arg2
         */
        (acc, { key, value }) => {
          acc[key] = value
          return acc
        },
        {},
      ),
    )

    const data = {
      a: 1,
      b: {
        c: 2,
      },
    }
    const result = await asyncMap((key, parent) => {
      const el = parent[key]
      if (R.is(Number, el)) {
        const md5 = randomMd5()
        const result$ = store$.pipe(
          pluck(md5),
          filter(v => v),
          first(),
        )
        setTimeout(() => {
          store.next({ key: md5, value: el })
        }, 1)
        return result$
      }
    }, data)
    expect(result).toEqual({ a: 1, b: { c: 2 } })
    expect(result).not.toBe(data)
  })
  it('Return promise generated by attributes', async () => {
    const data = {
      a: 100,
      b: 200,
    }

    /**
     * @param {string} key
     * @param {object} parent
     */
    const asyncFn = async (key, parent) => {
      const el = parent[key]
      if (R.is(Number, el)) {
        return await new Promise(function(resolve) {
          setTimeout(() => {
            parent[key] = `延时${el}ms`
            resolve()
          }, el)
        })
      }
      return el
    }

    const result = await asyncMap(asyncFn, data)
    expect(result).toEqual({ a: '延时100ms', b: '延时200ms' })
  })
})

describe('cache', () => {
  it(
    'Caching elements with the same key',
    marbles(m => {
      const sourceValues = {
        a: { id: 1, value: '1' },
        b: { id: 2, value: '2' },
        c: { id: 3, value: '3' },
        d: { id: 2, value: '4' },
        e: { id: 1, value: '5' },
      }
      const expectedValues = {
        a: { id: 1, value: '1' },
        b: { id: 2, value: '2' },
        c: { id: 3, value: '3' },
        d: { id: 2, value: '2' },
        e: { id: 1, value: '1' },
      }
      const cacheWithId = () => cache(({ id }) => id)
      const source = m.cold('  -abcde-|', sourceValues)
      const expected = m.cold('-abcde-|', expectedValues)

      const actual = source.pipe(cacheWithId())
      m.expect(actual).toBeObservable(expected)
    }),
  )
})

describe('groupOf', () => {
  it('Array grouping', () => {
    const data = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    expect(groupsOf(2)(data)).toEqual([[1, 2], [3, 4], [5, 6], [7, 8], [9]])
  })
})
